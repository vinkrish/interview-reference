{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structure Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks. Linear Data Structures Array It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n) LinkedList SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) Stack (LIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces Queue (FIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO Hierarchical Data Structure Binary Tree A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: The maximum number of nodes at level l = 2^(l-1) Maximum number of nodes, where h $\\to$ height of the tree 2^h-1 eg: They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories. Binary Search Tree A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList. Graph It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network. TRIE (Digital Tree or Radix Tree or Prefix Tree) It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M). Time Complexity It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity. Sorting Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n) In-place Sorting The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure. External Sorting Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations Searching Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"About"},{"location":"#data-structure","text":"Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks.","title":"Data Structure"},{"location":"#linear-data-structures","text":"","title":"Linear Data Structures"},{"location":"#array","text":"It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n)","title":"Array"},{"location":"#linkedlist","text":"SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n)","title":"LinkedList"},{"location":"#stack-lifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces","title":"Stack (LIFO)"},{"location":"#queue-fifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO","title":"Queue (FIFO)"},{"location":"#hierarchical-data-structure","text":"","title":"Hierarchical Data Structure"},{"location":"#binary-tree","text":"A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: The maximum number of nodes at level l = 2^(l-1) Maximum number of nodes, where h $\\to$ height of the tree 2^h-1 eg: They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories.","title":"Binary Tree"},{"location":"#binary-search-tree","text":"A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList.","title":"Binary Search Tree"},{"location":"#graph","text":"It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network.","title":"Graph"},{"location":"#trie-digital-tree-or-radix-tree-or-prefix-tree","text":"It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M).","title":"TRIE (Digital Tree or Radix Tree or Prefix Tree)"},{"location":"#time-complexity","text":"It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity.","title":"Time Complexity"},{"location":"#sorting","text":"Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n)","title":"Sorting"},{"location":"#in-place-sorting","text":"The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure.","title":"In-place Sorting"},{"location":"#external-sorting","text":"Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations","title":"External Sorting"},{"location":"#searching","text":"Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"Searching"},{"location":"angular/","text":"Angular Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes. Modules NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules. NgModule metadata NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property. NgModules and components NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule. Architecture overview Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views. Data Binding A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name. Pipes Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p> Directives Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent Routing The Angular router enables navigation from one view to the next as users perfrom application tasks. Forms Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Angular"},{"location":"angular/#angular","text":"Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes.","title":"Angular"},{"location":"angular/#modules","text":"NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules.","title":"Modules"},{"location":"angular/#ngmodule-metadata","text":"NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property.","title":"NgModule metadata"},{"location":"angular/#ngmodules-and-components","text":"NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule.","title":"NgModules and components"},{"location":"angular/#architecture-overview","text":"Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views.","title":"Architecture overview"},{"location":"angular/#data-binding","text":"A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name.","title":"Data Binding"},{"location":"angular/#pipes","text":"Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p>","title":"Pipes"},{"location":"angular/#directives","text":"Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent","title":"Directives"},{"location":"angular/#routing","text":"The Angular router enables navigation from one view to the next as users perfrom application tasks.","title":"Routing"},{"location":"angular/#forms","text":"Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Forms"},{"location":"java/","text":"Java Refer here for examples Java is a general-purpose programming language that is class-based, object-oriented, and designed to have as few implementation dependencies as possible. Class : A template that describes the kinds of state and behavior that objects of its type support. Object : An instance of class, which will have its own state and access to all of the behaviors defined by its class. State : (Instance variable). Behavior : (methods) where class' logic is stored or data gets manipulated. ... Inheritance : allows code defined in one class to be reused in other classes. Interfaces : 100 % abstract superclass that defines the methods a subclass must support but not how they must be supported. Java identifiers Legal Identifiers - rules the compiler uses to determine whether a name is legal. Sun's Java Code Conventions - for naming classes, vaiables and methods. JavaBeans Naming Standards Legal Identifiers Identifiers can't start with a number. Java keywords can't be a identifier. Identifiers are case-sensitive. Sun's Java Code Conventions Classes and interfaces - camelCase, for interfaces names should typically be adjectives eg:(Runnable, Serializable). Methods - lower_camelcase, names should be verb-noun pairs. Variables - lower_camelcase. Constants - are created by marking variables static and final, names should be uppercase letters with underscore characters as seperators. JavaBeans Naming Standards JavaBeans are Java classes that have properties: if property is not a boolean, the getter method's prefix must be get. if property is boolean, the getter method's prefix is either get or is. the setter method's prefix must be set. To complete the name of a getter or setter method, change the first letter of the property name to uppercase and then append. setter method signature must be marked public, with a void return type and argument that represents the property type. getter method signature must be marked public, take no arguments, and have a return type that matches the argument type of the setter method for that property. JavaBean spec supports events, (eg: mouse click is multicast to many objects). The objects that receive the information that an event occurred are called listeners. JavaBean Listener Naming Rules: Listener method names must end with the words \"Listener\". The type of listener to be added or removed must be passed as the argument to the method. Listener method names used to register/remove a listner with an event source must use the perfix add/remove, followed by the listener type. Class Declarations and Modifiers: Modifier Class Package Subclass(same pkg) Subclass(diff pkg) World public + + + + + protected + + + + no modifier + + + private + Modifiers: Access modifiers(public, protected, private) Non-access modifiers(strictfp, final, abstract) four access controls but three access modifiers, the fourth access control level (called default or package access) is what you get when you don't use any of the three access modifiers. Class Access(access a class) Access means visibility. class can be declared with default or public access. Default Access : class with default access can be seen only by classes within the same package. Public Access : gives all classes from all packages access to public class. Non-access class modifiers - used in addition to access control. (below are valid combination) public_final, default_final public_abstract, default_final strictfp_final, public_strictfp, default_strictfp Final Classes - class can't be subclassed. Abstract Classes - can never be instantiated. Interface It is a contract for what a class can do, without saying anything about how the class will do it. Interface variables must be public, static and final = constants. Interface methods: must not be static. can extend only Interface(many). cannot implement another interface or class. Modifiers On Member Access Modifiers: Public Members - all other classes can access the member. Private Members - can be accessed by code in which they are declared. Protected and Default Members - default member may be accessed only if the class accessing the member belongs to the same package, whereas a protected member can be accessed by a subclass. Default Members - package level. Nonaccess Member Modifiers: Final Methods - final keyword prevents the method from being overridden. Abstract Methods - declared but not implemented. Synchronized Methods - method can be accessed by only one thread at a time (applied only to methods). Native Methods - implemented in platform dependent code(like in C). Variable Declarations: Primitives - char, boolean, byte, short, int, long, double, float. Reference variables - used to refer (or access) an object. they can be static, instance variables, method parameters or local variables. Instance Variables : are defined inside class but outside any method, and are only initialized when class is instantiated. they are the fields that belong to each unique object. Array : objects that store multiple variables of the same type or variables that are all subclasses of the same type. can hold both primitives and object references. Final Variable : cannot be reinitialized (primitives) or reference variable cannot be changed but data within the object can be modified.(no final object only final references). Static variables and Methods : will exist independently of any instances created for the class (exist before we make instance of a class). one copy of static member exist regardless of number of instances of that class. static blocks are called before constructor. Enums : (java 5)> restrict a variable to have pre-defined value from an enumerated list. (items in the list are called enums). Enums can be declared as seperate class or class member but never within a method. ... Benefit of encapsulation - The ability to make changes in your implementation code without breaking the code of others who use your code. access methods - getters and setters(accessors and mutators). Hide implementation details behind a public programming interface, interface in the sense set of accessible methods your code makes available for other code to call - your code's API. Inheritance, Is-A, Has-A instanceof operator: returns true if the reference variable being tested is of the type being compared to. every class is subclass of class Object. inheritance relationships can be created by extending a class. Reasons to use inheritance: To promote code reuse, To use polymorphism. code reuse - generic functionality (like method) don't have to be reimplemented, all subclasses are guaranteed to have capabilities of the superclass. polymorphism - treats any subclass of classA as classA, which allows you to write methods that don't need to change if new subclasses are created. Runtime polymorphism doesn't happen when static IS-A : based on class inheritance and interface implementation, \"this thing is a type of that thing\". HAS-A : based on usage, class A HAS-A B if code in class A has a reference to an instance of class B. Polymorphic method invocations apply only to instance methods, at runtime the only things that are dynamically selected based on the actual object are instance methods. Only overriden instance methods are dynamically invoked based on the real object's type. Overridden Methods - based on object type. Polymorphism lets you use a abstract supertype reference to refer to one of its subtypes. Overloading Methods - based on reference type. ... Coupling and Cohesion : good OO design calls for loose coupling and high cohesion. ... A primitive literal is merely a source code representation of primitive data types(eg:integer, floating-point number, boolean or character). Assignment Variables are bit Holders, with a designed type. A variable referring to an object is just that - a reference variable. A reference variable bit holder contains bits representing a way to get to the object. Data Strucures Collections come in four basic flavors: Lists : Lists of things (classes that implement List) Sets : Unique things (classes that implement Set) Maps : Things with a unique ID (classes that implement Map) Queues : Things arranged by the order in which they are to be processed The core interfaces: The core concrete implementation classes: The interface and class hierarchy for collections: Arrays - Arrays are objects in Java that store multiple variables of same type. - Arrays can store either primitives or object references. List - methods related to the index. - eg:get(int index), indexof(Object o), add(int index, Object obj) ArrayList - ordered collection - implements RandomAccess, marker Interface - supports fast random access Vector - synchronized for thread safety - implement RandomAccess LinkedList - ordered by index position and also elements are doubly linked to one another - choose this for implementing a stack or queue Set - doesn't allow duplicates [using equals() method to determine identical objects] HashSet - unsorted, unordered Set - uses hashcode of the object being inserted LindkedHashset - ordered and unsorted Set - maintains doubly linked List across all elements - iterates through the order in which they were inserted TreeSet - Sorted Set - elements will be in ascending order, according to natural order Map - maps a unique key(ID) to a specific value - can search for a valued based on the key - uses equals() method to determine whether two keys are the same or different HashMap - unsorted and unordered Map - allows one null key and multiple null values in a collection LinkedHashMap - maintains insertion order (optionally access order) - faster iteration Hashtable - doesn't allow any null - can't synchronize class: only key methods of the class are synchronized TreeMap - Sorted Map - can define custom sort order(via a Comparable or Comparator) Queue - holds things to be processed in some way Priority Queue - to create \"priority-in, priority-out\" queue as opposed to FIFO - ordered either by natural ordering or according to a Comparator Comparable Interface: A comparable object is capable of comparing itself with another object. Comparable provides compareTo() method to sort elements. Comparable affects the original class, i.e., the actual class is modified. Used by Collections.sort() and java.util.Arrays.sort() method. Comparator Interface A comparator object is capable of comparing two different objects. It is not comparing its instances, but some other class's instances. Comparator provides compare() method to sort elements. Comparator doesn't affect the original class, i.e., the actual class is not modified. Developlment javac [options] [source files] java p[options] class [args] AOP Join Point represents the effective execution of a method where the aspect will be applied. Advice is the action taken by an aspect at the particular Join Point. eg: Before, After, AfterReturning, AfterThrowing. Spring AOP may create chains of Advice for one single Join Point. Pointcut is a predicate that matches Join Point. An Advice is associated with a Pointcut expression and runs at any Join Point matching that Pointcut. Equality Often in Java programs you need to compare two objects to determine if they are equal or not. It turns out there are two different kinds of equality one can determine about objects in Java, reference equality or logical equality . Equality operator (==) compares the references (addresses in memory) of the two Strings as two different numbers - this is known as Reference Equality. Logical equality compares the data of the objects instead of the value of the references. Why, you might ask, did the String class override the equals method inherited from the Object class? Because the equals method inherited from Object performs reference equality! Here is what the implementation of the equals method in Object looks like: public boolean equals(Object other) { return this == other; } Notice that the parameter type is Object - it must be Object or you will have overloaded equals instead of overriding it. Inheritance and the equals Method When overriding the equals method in classes making use of inheritance it is important to keep the super class and sub-class as loosely coupled as possible. Loosely coupled classes make as few assumptions about each other as possible making the code more maintainable over time. A secondary goal is to avoid duplication of code. HashCode General Contracts for hashCode() in Java: If two objects are considered equal, their hashcodes must also be equal. Whenever the hashCode() method is invoked on the same object more than once within a single execution of the application, hashCode() must return the same integer provided no information or fields used in equals and hashcode is modified. If two objects are not equaled by equals() method it is not require that there hashcode must be different. Though it\u2019s always good practice to return different hashCode for unequal object. You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet and HashTable. Hashing retrieval is a two-step process: Find the right bucket...using hashCode() Search the bucket for the right element...using equals() Follow this for complete example... Java 8 Functional Interfaces A functional interface has a single abstract method. Functional interfaces included with Java runtime. eg: Runnable, Callable, Comparator, TimerTask Prior to Java 8 it is known as Single Abstract Method (SAM) Types. Method References Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. Each time when you are using lambda expression to just referring a method, you can replace your lambda expression with method reference. Types of Method References Reference to a static method Reference to an instance method of a particular object or arbitrary object Reference to a constructor Details: 1. Reference to a Static Method You can refer to static method defined in the class. Following is the syntax and example which describe the process of referring static method in Java. ContainingClass::staticMethodName 2. Reference to an Instance Method like static methods, you can refer instance methods also containingObject::instanceMethodName 3. Reference to a Constructor You can refer a constructor by using the new keyword ClassName::new Optional Java 8 has introduced a new class Optional in java.util package. It is used to represent a value is present or absent. The main advantage of this new construct is that No more too many null checks. It avoids any runtime NullPointerExceptions and supports us in developing clean and neat Java APIs or Applications. Like Collections and arrays, it is also a Container to hold at most one value. Let us explore this new construct with some useful examples. Advantages of Java 8 Optional: Null checks are not required. No more NullPointerException at run-time. We can develop clean and neat APIs. No more Boiler plate code Lambda Expressions Lambda expressions can only appear in places where they will be assigned to a variable whose type is a functional interface. One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data. The previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly. Hibernate Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map ther inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns. Maven Tool used for building and managing any Java-based project. groupId It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins artifactId It is the name of the jar without version. eg: maven","title":"Java"},{"location":"java/#java","text":"Refer here for examples Java is a general-purpose programming language that is class-based, object-oriented, and designed to have as few implementation dependencies as possible. Class : A template that describes the kinds of state and behavior that objects of its type support. Object : An instance of class, which will have its own state and access to all of the behaviors defined by its class. State : (Instance variable). Behavior : (methods) where class' logic is stored or data gets manipulated. ... Inheritance : allows code defined in one class to be reused in other classes. Interfaces : 100 % abstract superclass that defines the methods a subclass must support but not how they must be supported.","title":"Java"},{"location":"java/#java-identifiers","text":"Legal Identifiers - rules the compiler uses to determine whether a name is legal. Sun's Java Code Conventions - for naming classes, vaiables and methods. JavaBeans Naming Standards","title":"Java identifiers"},{"location":"java/#legal-identifiers","text":"Identifiers can't start with a number. Java keywords can't be a identifier. Identifiers are case-sensitive.","title":"Legal Identifiers"},{"location":"java/#suns-java-code-conventions","text":"Classes and interfaces - camelCase, for interfaces names should typically be adjectives eg:(Runnable, Serializable). Methods - lower_camelcase, names should be verb-noun pairs. Variables - lower_camelcase. Constants - are created by marking variables static and final, names should be uppercase letters with underscore characters as seperators.","title":"Sun's Java Code Conventions"},{"location":"java/#javabeans-naming-standards","text":"JavaBeans are Java classes that have properties: if property is not a boolean, the getter method's prefix must be get. if property is boolean, the getter method's prefix is either get or is. the setter method's prefix must be set. To complete the name of a getter or setter method, change the first letter of the property name to uppercase and then append. setter method signature must be marked public, with a void return type and argument that represents the property type. getter method signature must be marked public, take no arguments, and have a return type that matches the argument type of the setter method for that property. JavaBean spec supports events, (eg: mouse click is multicast to many objects). The objects that receive the information that an event occurred are called listeners. JavaBean Listener Naming Rules: Listener method names must end with the words \"Listener\". The type of listener to be added or removed must be passed as the argument to the method. Listener method names used to register/remove a listner with an event source must use the perfix add/remove, followed by the listener type.","title":"JavaBeans Naming Standards"},{"location":"java/#class-declarations-and-modifiers","text":"Modifier Class Package Subclass(same pkg) Subclass(diff pkg) World public + + + + + protected + + + + no modifier + + + private + Modifiers: Access modifiers(public, protected, private) Non-access modifiers(strictfp, final, abstract) four access controls but three access modifiers, the fourth access control level (called default or package access) is what you get when you don't use any of the three access modifiers.","title":"Class Declarations and Modifiers:"},{"location":"java/#class-accessaccess-a-class","text":"Access means visibility. class can be declared with default or public access. Default Access : class with default access can be seen only by classes within the same package. Public Access : gives all classes from all packages access to public class. Non-access class modifiers - used in addition to access control. (below are valid combination) public_final, default_final public_abstract, default_final strictfp_final, public_strictfp, default_strictfp Final Classes - class can't be subclassed. Abstract Classes - can never be instantiated.","title":"Class Access(access a class)"},{"location":"java/#interface","text":"It is a contract for what a class can do, without saying anything about how the class will do it. Interface variables must be public, static and final = constants. Interface methods: must not be static. can extend only Interface(many). cannot implement another interface or class.","title":"Interface"},{"location":"java/#modifiers-on-member","text":"Access Modifiers: Public Members - all other classes can access the member. Private Members - can be accessed by code in which they are declared. Protected and Default Members - default member may be accessed only if the class accessing the member belongs to the same package, whereas a protected member can be accessed by a subclass. Default Members - package level. Nonaccess Member Modifiers: Final Methods - final keyword prevents the method from being overridden. Abstract Methods - declared but not implemented. Synchronized Methods - method can be accessed by only one thread at a time (applied only to methods). Native Methods - implemented in platform dependent code(like in C).","title":"Modifiers On Member"},{"location":"java/#variable-declarations","text":"Primitives - char, boolean, byte, short, int, long, double, float. Reference variables - used to refer (or access) an object. they can be static, instance variables, method parameters or local variables. Instance Variables : are defined inside class but outside any method, and are only initialized when class is instantiated. they are the fields that belong to each unique object. Array : objects that store multiple variables of the same type or variables that are all subclasses of the same type. can hold both primitives and object references. Final Variable : cannot be reinitialized (primitives) or reference variable cannot be changed but data within the object can be modified.(no final object only final references). Static variables and Methods : will exist independently of any instances created for the class (exist before we make instance of a class). one copy of static member exist regardless of number of instances of that class. static blocks are called before constructor. Enums : (java 5)> restrict a variable to have pre-defined value from an enumerated list. (items in the list are called enums). Enums can be declared as seperate class or class member but never within a method. ... Benefit of encapsulation - The ability to make changes in your implementation code without breaking the code of others who use your code. access methods - getters and setters(accessors and mutators). Hide implementation details behind a public programming interface, interface in the sense set of accessible methods your code makes available for other code to call - your code's API.","title":"Variable Declarations:"},{"location":"java/#inheritance-is-a-has-a","text":"instanceof operator: returns true if the reference variable being tested is of the type being compared to. every class is subclass of class Object. inheritance relationships can be created by extending a class. Reasons to use inheritance: To promote code reuse, To use polymorphism. code reuse - generic functionality (like method) don't have to be reimplemented, all subclasses are guaranteed to have capabilities of the superclass. polymorphism - treats any subclass of classA as classA, which allows you to write methods that don't need to change if new subclasses are created. Runtime polymorphism doesn't happen when static IS-A : based on class inheritance and interface implementation, \"this thing is a type of that thing\". HAS-A : based on usage, class A HAS-A B if code in class A has a reference to an instance of class B. Polymorphic method invocations apply only to instance methods, at runtime the only things that are dynamically selected based on the actual object are instance methods. Only overriden instance methods are dynamically invoked based on the real object's type. Overridden Methods - based on object type. Polymorphism lets you use a abstract supertype reference to refer to one of its subtypes. Overloading Methods - based on reference type. ... Coupling and Cohesion : good OO design calls for loose coupling and high cohesion. ... A primitive literal is merely a source code representation of primitive data types(eg:integer, floating-point number, boolean or character).","title":"Inheritance, Is-A, Has-A"},{"location":"java/#assignment","text":"Variables are bit Holders, with a designed type. A variable referring to an object is just that - a reference variable. A reference variable bit holder contains bits representing a way to get to the object.","title":"Assignment"},{"location":"java/#data-strucures","text":"Collections come in four basic flavors: Lists : Lists of things (classes that implement List) Sets : Unique things (classes that implement Set) Maps : Things with a unique ID (classes that implement Map) Queues : Things arranged by the order in which they are to be processed The core interfaces: The core concrete implementation classes: The interface and class hierarchy for collections: Arrays - Arrays are objects in Java that store multiple variables of same type. - Arrays can store either primitives or object references. List - methods related to the index. - eg:get(int index), indexof(Object o), add(int index, Object obj) ArrayList - ordered collection - implements RandomAccess, marker Interface - supports fast random access Vector - synchronized for thread safety - implement RandomAccess LinkedList - ordered by index position and also elements are doubly linked to one another - choose this for implementing a stack or queue Set - doesn't allow duplicates [using equals() method to determine identical objects] HashSet - unsorted, unordered Set - uses hashcode of the object being inserted LindkedHashset - ordered and unsorted Set - maintains doubly linked List across all elements - iterates through the order in which they were inserted TreeSet - Sorted Set - elements will be in ascending order, according to natural order Map - maps a unique key(ID) to a specific value - can search for a valued based on the key - uses equals() method to determine whether two keys are the same or different HashMap - unsorted and unordered Map - allows one null key and multiple null values in a collection LinkedHashMap - maintains insertion order (optionally access order) - faster iteration Hashtable - doesn't allow any null - can't synchronize class: only key methods of the class are synchronized TreeMap - Sorted Map - can define custom sort order(via a Comparable or Comparator) Queue - holds things to be processed in some way Priority Queue - to create \"priority-in, priority-out\" queue as opposed to FIFO - ordered either by natural ordering or according to a Comparator","title":"Data Strucures"},{"location":"java/#comparable-interface","text":"A comparable object is capable of comparing itself with another object. Comparable provides compareTo() method to sort elements. Comparable affects the original class, i.e., the actual class is modified. Used by Collections.sort() and java.util.Arrays.sort() method.","title":"Comparable Interface:"},{"location":"java/#comparator-interface","text":"A comparator object is capable of comparing two different objects. It is not comparing its instances, but some other class's instances. Comparator provides compare() method to sort elements. Comparator doesn't affect the original class, i.e., the actual class is not modified.","title":"Comparator Interface"},{"location":"java/#developlment","text":"javac [options] [source files] java p[options] class [args]","title":"Developlment"},{"location":"java/#aop","text":"Join Point represents the effective execution of a method where the aspect will be applied. Advice is the action taken by an aspect at the particular Join Point. eg: Before, After, AfterReturning, AfterThrowing. Spring AOP may create chains of Advice for one single Join Point. Pointcut is a predicate that matches Join Point. An Advice is associated with a Pointcut expression and runs at any Join Point matching that Pointcut.","title":"AOP"},{"location":"java/#equality","text":"Often in Java programs you need to compare two objects to determine if they are equal or not. It turns out there are two different kinds of equality one can determine about objects in Java, reference equality or logical equality . Equality operator (==) compares the references (addresses in memory) of the two Strings as two different numbers - this is known as Reference Equality. Logical equality compares the data of the objects instead of the value of the references. Why, you might ask, did the String class override the equals method inherited from the Object class? Because the equals method inherited from Object performs reference equality! Here is what the implementation of the equals method in Object looks like: public boolean equals(Object other) { return this == other; } Notice that the parameter type is Object - it must be Object or you will have overloaded equals instead of overriding it.","title":"Equality"},{"location":"java/#inheritance-and-the-equals-method","text":"When overriding the equals method in classes making use of inheritance it is important to keep the super class and sub-class as loosely coupled as possible. Loosely coupled classes make as few assumptions about each other as possible making the code more maintainable over time. A secondary goal is to avoid duplication of code.","title":"Inheritance and the equals Method"},{"location":"java/#hashcode","text":"General Contracts for hashCode() in Java: If two objects are considered equal, their hashcodes must also be equal. Whenever the hashCode() method is invoked on the same object more than once within a single execution of the application, hashCode() must return the same integer provided no information or fields used in equals and hashcode is modified. If two objects are not equaled by equals() method it is not require that there hashcode must be different. Though it\u2019s always good practice to return different hashCode for unequal object. You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet and HashTable. Hashing retrieval is a two-step process: Find the right bucket...using hashCode() Search the bucket for the right element...using equals() Follow this for complete example...","title":"HashCode"},{"location":"java/#java-8","text":"","title":"Java 8"},{"location":"java/#functional-interfaces","text":"A functional interface has a single abstract method. Functional interfaces included with Java runtime. eg: Runnable, Callable, Comparator, TimerTask Prior to Java 8 it is known as Single Abstract Method (SAM) Types.","title":"Functional Interfaces"},{"location":"java/#method-references","text":"Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. Each time when you are using lambda expression to just referring a method, you can replace your lambda expression with method reference. Types of Method References Reference to a static method Reference to an instance method of a particular object or arbitrary object Reference to a constructor Details: 1. Reference to a Static Method You can refer to static method defined in the class. Following is the syntax and example which describe the process of referring static method in Java. ContainingClass::staticMethodName 2. Reference to an Instance Method like static methods, you can refer instance methods also containingObject::instanceMethodName 3. Reference to a Constructor You can refer a constructor by using the new keyword ClassName::new","title":"Method References"},{"location":"java/#optional","text":"Java 8 has introduced a new class Optional in java.util package. It is used to represent a value is present or absent. The main advantage of this new construct is that No more too many null checks. It avoids any runtime NullPointerExceptions and supports us in developing clean and neat Java APIs or Applications. Like Collections and arrays, it is also a Container to hold at most one value. Let us explore this new construct with some useful examples. Advantages of Java 8 Optional: Null checks are not required. No more NullPointerException at run-time. We can develop clean and neat APIs. No more Boiler plate code","title":"Optional"},{"location":"java/#lambda-expressions","text":"Lambda expressions can only appear in places where they will be assigned to a variable whose type is a functional interface. One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data. The previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.","title":"Lambda Expressions"},{"location":"java/#hibernate","text":"Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map ther inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns.","title":"Hibernate"},{"location":"java/#maven","text":"Tool used for building and managing any Java-based project.","title":"Maven"},{"location":"java/#groupid","text":"It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins","title":"groupId"},{"location":"java/#artifactid","text":"It is the name of the jar without version. eg: maven","title":"artifactId"},{"location":"javascript/","text":"JS Playground Refer here for detailed examples const name = \"Vinay\"; console.log(`Hello ${name}!`); var x = 'global'; let y = 'global'; console.log(this.x); // \"global\" console.log(this.y); // undefined function varTest() { var x = 1; { var x = 2; // same variable! console.log(x); // 2 } console.log(x); // 2 } varTest(); function letTest() { let x = 1; { let x = 2; // different variable console.log(x); // 2 } console.log(x); // 1 } letTest(); function sayHello(name) { let closureText = \"hmm\"; return { yourName: name, introduce() { console.log(`Hello ${name}, my name in Vinay!`); console.log(`Closure says... ${closureText}!`); } } } let sh = sayHello('Angel'); sh.introduce(); function outer(param) { let x = param let inner = function() { console.log(x) } return inner; } let func = outer(9) func() let vinay = { job: 'SDE', speak() { console.log(\"Hell with Hello World!\"); }, wave: function() { console.log(\"just wave the hand\"); } } vinay.speak(); let obj1 = { name: 'Vinay' }; let obj2 = { sex: 'Male', Age: 30 }; for (const [key, value] of Object.entries(obj2)) { console.log(`${key}: ${value}`); } let clonedObj = {...obj2}; let mergedObj = {...obj1, ...obj2}; // spread syntax below does not work as one might expect: it spreads an array of arguments into the object literal, due to the rest parameter const merge = (...objects) => ( {...objects} ) const mergeFn = (...objects) => { return {...objects}; } console.log('Cloned Object:'); console.log(clonedObj); console.log('Merged Object:'); console.log(mergedObj); let copiedObj = obj2; obj2.sex = 'NA'; console.log('Copied Object sex changed:'); console.log(copiedObj); console.log('Cloned Object sex does not change:'); console.log(clonedObj); console.log(merge(obj1, obj2)); console.log(mergeFn(obj1, obj2)); let log = (name, ...details) => { console.log(`Welcome ${name}`); console.log(details); details.forEach(detail => { console.log(detail); }); for (const detail of details) { console.log(detail); } } let arr = [{sex: 'Male'}, {Age: 30}]; let details = [{married: 'No'} , ...arr]; log(\"Vinay\", ...details); log(\"Vinay\", details); console.log(\"Spread:\"); // spread(obj1, ...obj2); // object themselves are not iterable, but they become iterable when used in array or with iterating functions such as map(), reduce() and assign(). log(obj1, obj2); function GreetingService(name) { this.name = name; this.sayHi = function() { console.log(`Hello ${this.name}!`); }; this.sayHiAsync = function() { setTimeout(function(){ console.log(`Hello ${this.name}!`); },2000); } this.sayBye = function() { console.log(`Goodbye ${this.name}!`); } } let greeting = new GreetingService('Angel'); console.log(greeting); console.log(greeting.name); greeting.sayHi(); let { sayHi:hi } = new GreetingService('May Dupee'); hi(); greets = (name) => { let tempName = name; sayHi = () => { console.log(`Hello ${name}!`); } sayBye = () => { console.log(`Bye ${name}`); } return {newName: tempName, sayHi, sayBye}; } let greet = greets(\"Ango\"); console.log(greet); greet.sayHi(); let { newName, sayBye:bye } = greets(\"Dupee\"); console.log(newName); bye(); let arr = [1,2,3] square = (x) => { return x*x } let squared = arr.map(square) let squared = arr.map(x => square(x)) console.log(squared)","title":"JavaScript"},{"location":"javascript/#js-playground","text":"Refer here for detailed examples const name = \"Vinay\"; console.log(`Hello ${name}!`); var x = 'global'; let y = 'global'; console.log(this.x); // \"global\" console.log(this.y); // undefined function varTest() { var x = 1; { var x = 2; // same variable! console.log(x); // 2 } console.log(x); // 2 } varTest(); function letTest() { let x = 1; { let x = 2; // different variable console.log(x); // 2 } console.log(x); // 1 } letTest(); function sayHello(name) { let closureText = \"hmm\"; return { yourName: name, introduce() { console.log(`Hello ${name}, my name in Vinay!`); console.log(`Closure says... ${closureText}!`); } } } let sh = sayHello('Angel'); sh.introduce(); function outer(param) { let x = param let inner = function() { console.log(x) } return inner; } let func = outer(9) func() let vinay = { job: 'SDE', speak() { console.log(\"Hell with Hello World!\"); }, wave: function() { console.log(\"just wave the hand\"); } } vinay.speak(); let obj1 = { name: 'Vinay' }; let obj2 = { sex: 'Male', Age: 30 }; for (const [key, value] of Object.entries(obj2)) { console.log(`${key}: ${value}`); } let clonedObj = {...obj2}; let mergedObj = {...obj1, ...obj2}; // spread syntax below does not work as one might expect: it spreads an array of arguments into the object literal, due to the rest parameter const merge = (...objects) => ( {...objects} ) const mergeFn = (...objects) => { return {...objects}; } console.log('Cloned Object:'); console.log(clonedObj); console.log('Merged Object:'); console.log(mergedObj); let copiedObj = obj2; obj2.sex = 'NA'; console.log('Copied Object sex changed:'); console.log(copiedObj); console.log('Cloned Object sex does not change:'); console.log(clonedObj); console.log(merge(obj1, obj2)); console.log(mergeFn(obj1, obj2)); let log = (name, ...details) => { console.log(`Welcome ${name}`); console.log(details); details.forEach(detail => { console.log(detail); }); for (const detail of details) { console.log(detail); } } let arr = [{sex: 'Male'}, {Age: 30}]; let details = [{married: 'No'} , ...arr]; log(\"Vinay\", ...details); log(\"Vinay\", details); console.log(\"Spread:\"); // spread(obj1, ...obj2); // object themselves are not iterable, but they become iterable when used in array or with iterating functions such as map(), reduce() and assign(). log(obj1, obj2); function GreetingService(name) { this.name = name; this.sayHi = function() { console.log(`Hello ${this.name}!`); }; this.sayHiAsync = function() { setTimeout(function(){ console.log(`Hello ${this.name}!`); },2000); } this.sayBye = function() { console.log(`Goodbye ${this.name}!`); } } let greeting = new GreetingService('Angel'); console.log(greeting); console.log(greeting.name); greeting.sayHi(); let { sayHi:hi } = new GreetingService('May Dupee'); hi(); greets = (name) => { let tempName = name; sayHi = () => { console.log(`Hello ${name}!`); } sayBye = () => { console.log(`Bye ${name}`); } return {newName: tempName, sayHi, sayBye}; } let greet = greets(\"Ango\"); console.log(greet); greet.sayHi(); let { newName, sayBye:bye } = greets(\"Dupee\"); console.log(newName); bye(); let arr = [1,2,3] square = (x) => { return x*x } let squared = arr.map(square) let squared = arr.map(x => square(x)) console.log(squared)","title":"JS Playground"},{"location":"nodeJS/","text":"Follow here","title":"NodeJS"},{"location":"reactJS/","text":"How Virtual-DOM works in React React creates a virtual DOM. When state changes in a component it firstly runs a \u201cdiffing\u201d algorithm, which identifies what has changed in the virtual DOM. The second step is reconciliation, where it updates the DOM with the results of diff. The HTML DOM is always tree-structured \u2014 which is allowed by the structure of HTML document. The DOM trees are huge nowadays because of large apps. Since we are more and more pushed towards dynamic web apps (Single Page Applications \u2014 SPAs), we need to modify the DOM tree incessantly and a lot. And this is a real performance and development pain. The Virtual DOM is an abstraction of the HTML DOM. It is lightweight and detached from the browser-specific implementation details. It is not invented by React but it uses it and provides it for free. ReactElements lives in the virtual DOM. They make the basic nodes here. Once we defined the elements, ReactElements can be render into the \"real\" DOM. How React Works Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it\u2019s done faster than it would be in the regular DOM. For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent. JSX JSX is a syntax extension to JavaScript and comes with the full power of JavaScript. JSX produces React \u201celements\u201d. You can embed any JavaScript expression in JSX by wrapping it in curly braces. After compilation, JSX expressions become regular JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions. Eventhough React does not require JSX, it is the recommended way of describing our UI in React app. Redux Redux enforces keeping all state in a single centralized object graph. A callback function can be invoked when setState has finished and the component is re-rendered. Since the setState is asynchronous, which is why it takes in a second callback function. With this function, we can do what we want immediately after state has been updated. React: Someone clicked this 'Save' button. Action: Actions are payloads of information that send data from our application to our store. They are the only source of information for the store. We send them to the store using store.dispatch(). Primarly, they are just an object describes what happened in our app. Reducer: Reducers specify how the application\u2019s state changes in response to actions sent to the store. Remember that actions only describe what happened, but don\u2019t describe how the application\u2019s state changes. So this place determines how state will change to an action. Store: The Store is the object that brings Action and Reducer together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener); Handles unregistering of listeners via the function returned by subscribe(listener). React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this. Reducers are functions that take the current state in an action and then return a new state. setState() actions are asynchronous and are batched for performance gains. This is explained in documentation as below. setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains. This is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. Thus the setState calls are asynchronous as well as batched for better UI experience and performance. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children } Questions What are controlled and uncontrolled components in React? This relates to stateful DOM components (form elements) and the difference: In HTML, form elements such as <input> , <textarea> , and <select> typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g. onChange is fired as the state will be updated. A form element whose value is controlled by React in this way is called a \"controlled component\". With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component \u201ccontrols\u201d it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a \u201cdumb component\u201d. A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML. In most (or all) cases we should use controlled components. What is render() in React? And explain its purpose? Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <form> , <group> , <div> etc. This function must be kept pure i.e., it must return the same result each time it is invoked. What is React.cloneElement? And the difference with this.props.children? React.cloneElement clone and return a new React element using using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved. React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element. How Virtual-DOM is more efficient than Dirty checking? In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering. The virtual DOM is used for efficient re-rendering of the DOM. This isn\u2019t really related to dirty checking your data. We could re-render using a virtual DOM with or without dirty checking. In fact, the diff algorithm is a dirty checker itself. We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing. What is PureComponent? When to use PureComponent over Component? PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for us. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called. When comparing previous props and state to next, a shallow comparison will check that primitives have the same value (eg, 1 equals 1 or that true equals true) and that the references are the same between more complex javascript values like objects and arrays. It is good to prefer PureComponent over Component whenever we never mutate our objects. What is Redux Thunk used for? Redux thunk is middleware that allows us to write action creators that return a function instead of an action. The thunk can then be used to delay the dispatch of an action if a certain condition is met. This allows us to handle the asyncronous dispatching of actions. The inner function receives the store methods dispatch and getState as parameters. What is a higher order component? A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API. They are a pattern that emerges from React\u2019s compositional nature. A higher-order component is a function that takes a component and returns a new component. HOC\u2019s allow you to reuse code, logic and bootstrap abstraction. HOCs are common in third-party React libraries. The most common is probably Redux\u2019s connect function. Beyond simply sharing utility libraries and simple composition, HOCs are the best way to share behavior between React Components. If you find yourself writing a lot of code in different places that does the same thing, you may be able to refactor that code into a reusable HOC. What is the difference between state and props? The state is a data structure that starts with a default value when a Component mounts. It may be mutated across time, mostly as a result of user events. Props (short for properties) are a Component\u2019s configuration. Props are how components talk to each other. They are received from above component and immutable as far as the Component receiving them is concerned. A Component cannot change its props, but it is responsible for putting together the props of its child Components. Props do not have to just be data \u2014 callback functions may be passed in as props. There is also the case that we can have default props so that props are set even if a parent component doesn\u2019t pass props down. What are the differences between a class component and functional component? Class components allows us to use additional features such as local state and lifecycle hooks. Also, to enable our component to have direct access to our store and thus holds state. When our component just receives props and renders them to the page, this is a \u2018stateless component\u2019, for which a pure function can be used. These are also called dumb components or presentational components.","title":"ReactJS"},{"location":"reactJS/#how-virtual-dom-works-in-react","text":"React creates a virtual DOM. When state changes in a component it firstly runs a \u201cdiffing\u201d algorithm, which identifies what has changed in the virtual DOM. The second step is reconciliation, where it updates the DOM with the results of diff. The HTML DOM is always tree-structured \u2014 which is allowed by the structure of HTML document. The DOM trees are huge nowadays because of large apps. Since we are more and more pushed towards dynamic web apps (Single Page Applications \u2014 SPAs), we need to modify the DOM tree incessantly and a lot. And this is a real performance and development pain. The Virtual DOM is an abstraction of the HTML DOM. It is lightweight and detached from the browser-specific implementation details. It is not invented by React but it uses it and provides it for free. ReactElements lives in the virtual DOM. They make the basic nodes here. Once we defined the elements, ReactElements can be render into the \"real\" DOM.","title":"How Virtual-DOM works in React"},{"location":"reactJS/#how-react-works","text":"Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it\u2019s done faster than it would be in the regular DOM. For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent.","title":"How React Works"},{"location":"reactJS/#jsx","text":"JSX is a syntax extension to JavaScript and comes with the full power of JavaScript. JSX produces React \u201celements\u201d. You can embed any JavaScript expression in JSX by wrapping it in curly braces. After compilation, JSX expressions become regular JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions. Eventhough React does not require JSX, it is the recommended way of describing our UI in React app.","title":"JSX"},{"location":"reactJS/#redux","text":"Redux enforces keeping all state in a single centralized object graph. A callback function can be invoked when setState has finished and the component is re-rendered. Since the setState is asynchronous, which is why it takes in a second callback function. With this function, we can do what we want immediately after state has been updated. React: Someone clicked this 'Save' button. Action: Actions are payloads of information that send data from our application to our store. They are the only source of information for the store. We send them to the store using store.dispatch(). Primarly, they are just an object describes what happened in our app. Reducer: Reducers specify how the application\u2019s state changes in response to actions sent to the store. Remember that actions only describe what happened, but don\u2019t describe how the application\u2019s state changes. So this place determines how state will change to an action. Store: The Store is the object that brings Action and Reducer together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener); Handles unregistering of listeners via the function returned by subscribe(listener). React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this. Reducers are functions that take the current state in an action and then return a new state. setState() actions are asynchronous and are batched for performance gains. This is explained in documentation as below. setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains. This is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. Thus the setState calls are asynchronous as well as batched for better UI experience and performance. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children }","title":"Redux"},{"location":"reactJS/#questions","text":"What are controlled and uncontrolled components in React? This relates to stateful DOM components (form elements) and the difference: In HTML, form elements such as <input> , <textarea> , and <select> typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g. onChange is fired as the state will be updated. A form element whose value is controlled by React in this way is called a \"controlled component\". With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component \u201ccontrols\u201d it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a \u201cdumb component\u201d. A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML. In most (or all) cases we should use controlled components. What is render() in React? And explain its purpose? Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <form> , <group> , <div> etc. This function must be kept pure i.e., it must return the same result each time it is invoked. What is React.cloneElement? And the difference with this.props.children? React.cloneElement clone and return a new React element using using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved. React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element. How Virtual-DOM is more efficient than Dirty checking? In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering. The virtual DOM is used for efficient re-rendering of the DOM. This isn\u2019t really related to dirty checking your data. We could re-render using a virtual DOM with or without dirty checking. In fact, the diff algorithm is a dirty checker itself. We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing. What is PureComponent? When to use PureComponent over Component? PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for us. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called. When comparing previous props and state to next, a shallow comparison will check that primitives have the same value (eg, 1 equals 1 or that true equals true) and that the references are the same between more complex javascript values like objects and arrays. It is good to prefer PureComponent over Component whenever we never mutate our objects. What is Redux Thunk used for? Redux thunk is middleware that allows us to write action creators that return a function instead of an action. The thunk can then be used to delay the dispatch of an action if a certain condition is met. This allows us to handle the asyncronous dispatching of actions. The inner function receives the store methods dispatch and getState as parameters. What is a higher order component? A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API. They are a pattern that emerges from React\u2019s compositional nature. A higher-order component is a function that takes a component and returns a new component. HOC\u2019s allow you to reuse code, logic and bootstrap abstraction. HOCs are common in third-party React libraries. The most common is probably Redux\u2019s connect function. Beyond simply sharing utility libraries and simple composition, HOCs are the best way to share behavior between React Components. If you find yourself writing a lot of code in different places that does the same thing, you may be able to refactor that code into a reusable HOC. What is the difference between state and props? The state is a data structure that starts with a default value when a Component mounts. It may be mutated across time, mostly as a result of user events. Props (short for properties) are a Component\u2019s configuration. Props are how components talk to each other. They are received from above component and immutable as far as the Component receiving them is concerned. A Component cannot change its props, but it is responsible for putting together the props of its child Components. Props do not have to just be data \u2014 callback functions may be passed in as props. There is also the case that we can have default props so that props are set even if a parent component doesn\u2019t pass props down. What are the differences between a class component and functional component? Class components allows us to use additional features such as local state and lifecycle hooks. Also, to enable our component to have direct access to our store and thus holds state. When our component just receives props and renders them to the page, this is a \u2018stateless component\u2019, for which a pure function can be used. These are also called dumb components or presentational components.","title":"Questions"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structure Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks. Linear Data Structures Array It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n) LinkedList SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) Stack (LIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces Queue (FIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO Hierarchical Data Structure Binary Tree A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: where h \\to height of the tree Total Number of leaf nodes in a Binary Tree = Total Number of nodes with 2 children + 1 A binary tree of n nodes has (n+1) null references. Minimum number of nodes: n = h+1 Maximum number of nodes at any level \u2018l\u2019 in a binary tree: n = 2^l In a Full Binary Tree, maximum number of nodes: n = 2^{h+1}-1 and minimum number of nodes: n = 2h+1 Types of Binary Tree Full Binary Tree : A binary tree is said to be a full binary tree when each internal node has zero or two children Perfect Binary Tree : A perfect binary tree is a special type of binary tree in which all the leaf nodes are at the same level, and each internal node has two children Complete Binary Tree : A binary tree is referred to as a complete binary tree when all of its levels are completely filled. The only exception is possibly the lowest level in which the nodes must lean as left as possible Degenerate or Pathological Tree : A degenerate or pathological tree is a type of binary tree in which each internal node has a single child, either the left child or the right child Skewed Binary Tree : A binary tree is said to be a skewed binary tree if all of its internal nodes have exactly one child, and either left children or right children dominate the tree Balanced Binary Tree : A balanced binary tree is also a special type of binary tree in which the difference of height between the left and the right subtrees for each node is at most one Applications There are many other data structures that are derived from the idea of a binary tree, such as binary search tree, syntax tree, heap, hash tree, red-black tree, binary trie, AVL tree, GGM tree, T-tree, and Treap. They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories. Other real-life applications of a binary tree include binary space partition, heap sort, virtual memory management, and indexing. Binary Search Tree A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList. Graph It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network. TRIE (Digital Tree or Radix Tree or Prefix Tree) It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M). Time Complexity It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity. Sorting Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n) In-place Sorting The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure. External Sorting Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations Searching Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"About"},{"location":"#data-structure","text":"Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks.","title":"Data Structure"},{"location":"#linear-data-structures","text":"","title":"Linear Data Structures"},{"location":"#array","text":"It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n)","title":"Array"},{"location":"#linkedlist","text":"SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n)","title":"LinkedList"},{"location":"#stack-lifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces","title":"Stack (LIFO)"},{"location":"#queue-fifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO","title":"Queue (FIFO)"},{"location":"#hierarchical-data-structure","text":"","title":"Hierarchical Data Structure"},{"location":"#binary-tree","text":"A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: where h \\to height of the tree Total Number of leaf nodes in a Binary Tree = Total Number of nodes with 2 children + 1 A binary tree of n nodes has (n+1) null references. Minimum number of nodes: n = h+1 Maximum number of nodes at any level \u2018l\u2019 in a binary tree: n = 2^l In a Full Binary Tree, maximum number of nodes: n = 2^{h+1}-1 and minimum number of nodes: n = 2h+1","title":"Binary Tree"},{"location":"#types-of-binary-tree","text":"Full Binary Tree : A binary tree is said to be a full binary tree when each internal node has zero or two children Perfect Binary Tree : A perfect binary tree is a special type of binary tree in which all the leaf nodes are at the same level, and each internal node has two children Complete Binary Tree : A binary tree is referred to as a complete binary tree when all of its levels are completely filled. The only exception is possibly the lowest level in which the nodes must lean as left as possible Degenerate or Pathological Tree : A degenerate or pathological tree is a type of binary tree in which each internal node has a single child, either the left child or the right child Skewed Binary Tree : A binary tree is said to be a skewed binary tree if all of its internal nodes have exactly one child, and either left children or right children dominate the tree Balanced Binary Tree : A balanced binary tree is also a special type of binary tree in which the difference of height between the left and the right subtrees for each node is at most one","title":"Types of Binary Tree"},{"location":"#applications","text":"There are many other data structures that are derived from the idea of a binary tree, such as binary search tree, syntax tree, heap, hash tree, red-black tree, binary trie, AVL tree, GGM tree, T-tree, and Treap. They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories. Other real-life applications of a binary tree include binary space partition, heap sort, virtual memory management, and indexing.","title":"Applications"},{"location":"#binary-search-tree","text":"A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList.","title":"Binary Search Tree"},{"location":"#graph","text":"It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network.","title":"Graph"},{"location":"#trie-digital-tree-or-radix-tree-or-prefix-tree","text":"It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M).","title":"TRIE (Digital Tree or Radix Tree or Prefix Tree)"},{"location":"#time-complexity","text":"It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity.","title":"Time Complexity"},{"location":"#sorting","text":"Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n)","title":"Sorting"},{"location":"#in-place-sorting","text":"The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure.","title":"In-place Sorting"},{"location":"#external-sorting","text":"Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations","title":"External Sorting"},{"location":"#searching","text":"Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"Searching"},{"location":"angular/","text":"Angular Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes. Modules NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules. NgModule metadata NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property. NgModules and components NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule. Architecture overview Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views. Data Binding A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name. Pipes Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p> Directives Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent Routing The Angular router enables navigation from one view to the next as users perfrom application tasks. Forms Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Angular"},{"location":"angular/#angular","text":"Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes.","title":"Angular"},{"location":"angular/#modules","text":"NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules.","title":"Modules"},{"location":"angular/#ngmodule-metadata","text":"NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property.","title":"NgModule metadata"},{"location":"angular/#ngmodules-and-components","text":"NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule.","title":"NgModules and components"},{"location":"angular/#architecture-overview","text":"Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views.","title":"Architecture overview"},{"location":"angular/#data-binding","text":"A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name.","title":"Data Binding"},{"location":"angular/#pipes","text":"Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p>","title":"Pipes"},{"location":"angular/#directives","text":"Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent","title":"Directives"},{"location":"angular/#routing","text":"The Angular router enables navigation from one view to the next as users perfrom application tasks.","title":"Routing"},{"location":"angular/#forms","text":"Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Forms"},{"location":"java/","text":"Java Refer here for examples Java is a general-purpose programming language that is class-based, object-oriented, and designed to have as few implementation dependencies as possible. Class : A template that describes the kinds of state and behavior that objects of its type support. Object : An instance of class, which will have its own state and access to all of the behaviors defined by its class. State : (Instance variable). Behavior : (methods) where class' logic is stored or data gets manipulated. ... Inheritance : allows code defined in one class to be reused in other classes. Interfaces : 100 % abstract superclass that defines the methods a subclass must support but not how they must be supported. Java identifiers Legal Identifiers - rules the compiler uses to determine whether a name is legal. Sun's Java Code Conventions - for naming classes, vaiables and methods. JavaBeans Naming Standards Legal Identifiers Identifiers can't start with a number. Java keywords can't be a identifier. Identifiers are case-sensitive. Sun's Java Code Conventions Classes and interfaces - camelCase, for interfaces names should typically be adjectives eg:(Runnable, Serializable). Methods - lower_camelcase, names should be verb-noun pairs. Variables - lower_camelcase. Constants - are created by marking variables static and final, names should be uppercase letters with underscore characters as seperators. JavaBeans Naming Standards JavaBeans are Java classes that have properties: if property is not a boolean, the getter method's prefix must be get. if property is boolean, the getter method's prefix is either get or is. the setter method's prefix must be set. To complete the name of a getter or setter method, change the first letter of the property name to uppercase and then append. setter method signature must be marked public, with a void return type and argument that represents the property type. getter method signature must be marked public, take no arguments, and have a return type that matches the argument type of the setter method for that property. JavaBean spec supports events, (eg: mouse click is multicast to many objects). The objects that receive the information that an event occurred are called listeners. JavaBean Listener Naming Rules: Listener method names must end with the words \"Listener\". The type of listener to be added or removed must be passed as the argument to the method. Listener method names used to register/remove a listner with an event source must use the perfix add/remove, followed by the listener type. Class Declarations and Modifiers: Modifier Class Package Subclass(same pkg) Subclass(diff pkg) World public + + + + + protected + + + + no modifier + + + private + Modifiers: Access modifiers(public, protected, private) Non-access modifiers(strictfp, final, abstract) four access controls but three access modifiers, the fourth access control level (called default or package access) is what you get when you don't use any of the three access modifiers. Class Access(access a class) Access means visibility. class can be declared with default or public access. Default Access : class with default access can be seen only by classes within the same package. Public Access : gives all classes from all packages access to public class. Non-access class modifiers - used in addition to access control. (below are valid combination) public_final, default_final public_abstract, default_final strictfp_final, public_strictfp, default_strictfp Final Classes - class can't be subclassed. Abstract Classes - can never be instantiated. Interface It is a contract for what a class can do, without saying anything about how the class will do it. Interface variables must be public, static and final = constants. Interface methods: must not be static. can extend only Interface(many). cannot implement another interface or class. Modifiers On Member Access Modifiers: Public Members - all other classes can access the member. Private Members - can be accessed by code in which they are declared. Protected and Default Members - default member may be accessed only if the class accessing the member belongs to the same package, whereas a protected member can be accessed by a subclass. Default Members - package level. Nonaccess Member Modifiers: Final Methods - final keyword prevents the method from being overridden. Abstract Methods - declared but not implemented. Synchronized Methods - method can be accessed by only one thread at a time (applied only to methods). Native Methods - implemented in platform dependent code(like in C). Variable Declarations: Primitives - char, boolean, byte, short, int, long, double, float. Reference variables - used to refer (or access) an object. they can be static, instance variables, method parameters or local variables. Instance Variables : are defined inside class but outside any method, and are only initialized when class is instantiated. they are the fields that belong to each unique object. Array : objects that store multiple variables of the same type or variables that are all subclasses of the same type. can hold both primitives and object references. Final Variable : cannot be reinitialized (primitives) or reference variable cannot be changed but data within the object can be modified.(no final object only final references). Static variables and Methods : will exist independently of any instances created for the class (exist before we make instance of a class). one copy of static member exist regardless of number of instances of that class. static blocks are called before constructor. Enums : (java 5)> restrict a variable to have pre-defined value from an enumerated list. (items in the list are called enums). Enums can be declared as seperate class or class member but never within a method. ... Benefit of encapsulation - The ability to make changes in your implementation code without breaking the code of others who use your code. access methods - getters and setters(accessors and mutators). Hide implementation details behind a public programming interface, interface in the sense set of accessible methods your code makes available for other code to call - your code's API. Inheritance, Is-A, Has-A instanceof operator: returns true if the reference variable being tested is of the type being compared to. every class is subclass of class Object. inheritance relationships can be created by extending a class. Reasons to use inheritance: To promote code reuse, To use polymorphism. code reuse - generic functionality (like method) don't have to be reimplemented, all subclasses are guaranteed to have capabilities of the superclass. polymorphism - treats any subclass of classA as classA, which allows you to write methods that don't need to change if new subclasses are created. Runtime polymorphism doesn't happen when static IS-A : based on class inheritance and interface implementation, \"this thing is a type of that thing\". HAS-A : based on usage, class A HAS-A B if code in class A has a reference to an instance of class B. Polymorphic method invocations apply only to instance methods, at runtime the only things that are dynamically selected based on the actual object are instance methods. Only overriden instance methods are dynamically invoked based on the real object's type. Overridden Methods - based on object type. Polymorphism lets you use a abstract supertype reference to refer to one of its subtypes. Overloading Methods - based on reference type. ... Coupling and Cohesion : good OO design calls for loose coupling and high cohesion. ... A primitive literal is merely a source code representation of primitive data types(eg:integer, floating-point number, boolean or character). Assignment Variables are bit Holders, with a designed type. A variable referring to an object is just that - a reference variable. A reference variable bit holder contains bits representing a way to get to the object. Reification In computing, reification has come to mean an explicit representation of a type \u2014 that is, run-time type information. In Java, arrays reify information about their component types, while generic types do not reify information about their type parameters (while the type of a parameterized type is reified without its type parameters). In Java, we say that a type is reifiable if the type is completely represented at run time \u2014 that is, if erasure does not remove any useful information. To be precise, a type is reifiable if it is one of the following: A primitive type (such as int) A nonparameterized class or interface type (such as Number, String, or Runnable) A parameterized type in which all type arguments are unbounded wildcards (such as List<?>, ArrayList<?>, or Map<?, ?> ) A raw type (such as List, ArrayList, or Map) An array whose component type is reifiable (such as int[], Number[], List<?>[], List[], or int[][] ) A type is not reifiable if it is one of the following: A type variable (such as T) A parameterized type with actual parameters (such as List<Number> , ArrayList<String> , or Map<String, Integer> ) A parameterized type with a bound (such as List<? extends Number> or Comparable<? super String> ) So the type List<? extends Object> is not reifiable, even though it is equivalent to List<?> . Defining reifiable types in this way makes them easy to identify syntactically. Principle of Indecent Exposure: This principle guarantees that the component type at compile time will be a reifiable type. Based on above principle, never publicly expose an array where the components do not have a reifiable type. Principle of Truth in Advertising: This principle guarantees that the reified component type returned at run time must be a subtype of the reifiable component type declared at compile time. Converse to cast-iron guarantee, above principle illustrates if there are unchecked warnings, then casts inserted by erasure may fail. Generics In Java 5, the class Class has been made generic, and now has the form Class<T> . What does the T stand for? An instance of type Class<T> represents the type T. For example, String.class has type Class<String> . cast-iron guarantee: No cast inserted by erasure will fail, so long as there are no unchecked warnings. The Get and Put Principle: - use an extends wildcard when you only get values out of a structure - use a super wildcard when you only put values into a structure - don\u2019t use a wildcard when you both get and put. Why can't you create generic array type? Java's arrays (unlike generics) contain, at runtime, information about its component type. So you must know the component type when you create the array. Reflection Every type in Java, including primitive types and array types, has a class literal and a corresponding class token. generics for reflection: some of the types used for reflection are now generic types. reflection for generics: reflection now returns information about generic types. Class represents information about the type of an object at run time. The method getClass() is defined on every object and returns a class token that represents the reified type information carried by that object at run-time. class always represents a reifiable type, there is no point in parameterizing the class Class with a type that is not reifiable. Hence, the two main methods for producing a class with a type parameter, namely the getClass method and class literals, are both designed to yield a reifiable type for the type parameter in all cases. Each class token corresponds to a reifiable type. If you try to reflect a parameterized type, you get the reified information for the corresponding raw type. Data Strucures Collections come in four basic flavors: Lists : Lists of things (classes that implement List) Sets : Unique things (classes that implement Set) Maps : Things with a unique ID (classes that implement Map) Queues : Things arranged by the order in which they are to be processed The core interfaces: The core concrete implementation classes: The interface and class hierarchy for collections: Arrays Arrays are objects in Java that store multiple variables of same type. Arrays can store either primitives or object references. List methods related to the index. eg:get(int index), indexof(Object o), add(int index, Object obj) ArrayList ordered collection implements RandomAccess, marker Interface supports fast random access Vector synchronized for thread safety implement RandomAccess LinkedList ordered by index position and also elements are doubly linked to one another choose this for implementing a stack or queue Set doesn't allow duplicates [using equals() method to determine identical objects] HashSet unsorted, unordered Set uses hashcode of the object being inserted LindkedHashset ordered and unsorted Set maintains doubly linked List across all elements iterates through the order in which they were inserted TreeSet Sorted Set elements will be in ascending order, according to natural order Map maps a unique key(ID) to a specific value can search for a valued based on the key uses equals() method to determine whether two keys are the same or different HashMap unsorted and unordered Map allows one null key and multiple null values in a collection LinkedHashMap maintains insertion order (optionally access order) faster iteration Hashtable doesn't allow any null can't synchronize class: only key methods of the class are synchronized TreeMap Sorted Map can define custom sort order(via a Comparable or Comparator) Queue holds things to be processed in some way Priority Queue to create \"priority-in, priority-out\" queue as opposed to FIFO ordered either by natural ordering or according to a Comparator Comparable Interface: A comparable object is capable of comparing itself with another object. Comparable provides compareTo() method to sort elements. Comparable affects the original class, i.e., the actual class is modified. Used by Collections.sort() and java.util.Arrays.sort() method. Comparator Interface A comparator object is capable of comparing two different objects. It is not comparing its instances, but some other class's instances. Comparator provides compare() method to sort elements. Comparator doesn't affect the original class, i.e., the actual class is not modified. Developlment javac [options] [source files] java p[options] class [args] AOP Join Point represents the effective execution of a method where the aspect will be applied. Advice is the action taken by an aspect at the particular Join Point. eg: Before, After, AfterReturning, AfterThrowing. Spring AOP may create chains of Advice for one single Join Point. Pointcut is a predicate that matches Join Point. An Advice is associated with a Pointcut expression and runs at any Join Point matching that Pointcut. Equality Often in Java programs you need to compare two objects to determine if they are equal or not. It turns out there are two different kinds of equality one can determine about objects in Java, reference equality or logical equality . Equality operator (==) compares the references (addresses in memory) of the two Strings as two different numbers - this is known as Reference Equality. Logical equality compares the data of the objects instead of the value of the references. Why, you might ask, did the String class override the equals method inherited from the Object class? Because the equals method inherited from Object performs reference equality! Here is what the implementation of the equals method in Object looks like: public boolean equals(Object other) { return this == other; } Notice that the parameter type is Object - it must be Object or you will have overloaded equals instead of overriding it. Inheritance and the equals Method When overriding the equals method in classes making use of inheritance it is important to keep the super class and sub-class as loosely coupled as possible. Loosely coupled classes make as few assumptions about each other as possible making the code more maintainable over time. A secondary goal is to avoid duplication of code. HashCode General Contracts for hashCode() in Java: If two objects are considered equal, their hashcodes must also be equal. Whenever the hashCode() method is invoked on the same object more than once within a single execution of the application, hashCode() must return the same integer provided no information or fields used in equals and hashcode is modified. If two objects are not equaled by equals() method it is not require that there hashcode must be different. Though it\u2019s always good practice to return different hashCode for unequal object. You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet and HashTable. Hashing retrieval is a two-step process: Find the right bucket...using hashCode() Search the bucket for the right element...using equals() Follow this for complete example... Java 8 Functional Interfaces A functional interface has a single abstract method. Functional interfaces included with Java runtime. eg: Runnable, Callable, Comparator, TimerTask Prior to Java 8 it is known as Single Abstract Method (SAM) Types. Method References Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. Each time when you are using lambda expression to just referring a method, you can replace your lambda expression with method reference. Types of Method References Reference to a static method Reference to an instance method of a particular object or arbitrary object Reference to a constructor Details: 1. Reference to a Static Method You can refer to static method defined in the class. Following is the syntax and example which describe the process of referring static method in Java. ContainingClass::staticMethodName 2. Reference to an Instance Method like static methods, you can refer instance methods also containingObject::instanceMethodName 3. Reference to a Constructor You can refer a constructor by using the new keyword ClassName::new Optional Java 8 has introduced a new class Optional in java.util package. It is used to represent a value is present or absent. The main advantage of this new construct is that No more too many null checks. It avoids any runtime NullPointerExceptions and supports us in developing clean and neat Java APIs or Applications. Like Collections and arrays, it is also a Container to hold at most one value. Let us explore this new construct with some useful examples. Advantages of Java 8 Optional: Null checks are not required. No more NullPointerException at run-time. We can develop clean and neat APIs. No more Boiler plate code Lambda Expressions Lambda expressions can only appear in places where they will be assigned to a variable whose type is a functional interface. One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data. The previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly. Hibernate Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map ther inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns. Maven Tool used for building and managing any Java-based project. groupId It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins artifactId It is the name of the jar without version. eg: maven","title":"Java"},{"location":"java/#java","text":"Refer here for examples Java is a general-purpose programming language that is class-based, object-oriented, and designed to have as few implementation dependencies as possible. Class : A template that describes the kinds of state and behavior that objects of its type support. Object : An instance of class, which will have its own state and access to all of the behaviors defined by its class. State : (Instance variable). Behavior : (methods) where class' logic is stored or data gets manipulated. ... Inheritance : allows code defined in one class to be reused in other classes. Interfaces : 100 % abstract superclass that defines the methods a subclass must support but not how they must be supported.","title":"Java"},{"location":"java/#java-identifiers","text":"Legal Identifiers - rules the compiler uses to determine whether a name is legal. Sun's Java Code Conventions - for naming classes, vaiables and methods. JavaBeans Naming Standards","title":"Java identifiers"},{"location":"java/#legal-identifiers","text":"Identifiers can't start with a number. Java keywords can't be a identifier. Identifiers are case-sensitive.","title":"Legal Identifiers"},{"location":"java/#suns-java-code-conventions","text":"Classes and interfaces - camelCase, for interfaces names should typically be adjectives eg:(Runnable, Serializable). Methods - lower_camelcase, names should be verb-noun pairs. Variables - lower_camelcase. Constants - are created by marking variables static and final, names should be uppercase letters with underscore characters as seperators.","title":"Sun's Java Code Conventions"},{"location":"java/#javabeans-naming-standards","text":"JavaBeans are Java classes that have properties: if property is not a boolean, the getter method's prefix must be get. if property is boolean, the getter method's prefix is either get or is. the setter method's prefix must be set. To complete the name of a getter or setter method, change the first letter of the property name to uppercase and then append. setter method signature must be marked public, with a void return type and argument that represents the property type. getter method signature must be marked public, take no arguments, and have a return type that matches the argument type of the setter method for that property. JavaBean spec supports events, (eg: mouse click is multicast to many objects). The objects that receive the information that an event occurred are called listeners. JavaBean Listener Naming Rules: Listener method names must end with the words \"Listener\". The type of listener to be added or removed must be passed as the argument to the method. Listener method names used to register/remove a listner with an event source must use the perfix add/remove, followed by the listener type.","title":"JavaBeans Naming Standards"},{"location":"java/#class-declarations-and-modifiers","text":"Modifier Class Package Subclass(same pkg) Subclass(diff pkg) World public + + + + + protected + + + + no modifier + + + private + Modifiers: Access modifiers(public, protected, private) Non-access modifiers(strictfp, final, abstract) four access controls but three access modifiers, the fourth access control level (called default or package access) is what you get when you don't use any of the three access modifiers.","title":"Class Declarations and Modifiers:"},{"location":"java/#class-accessaccess-a-class","text":"Access means visibility. class can be declared with default or public access. Default Access : class with default access can be seen only by classes within the same package. Public Access : gives all classes from all packages access to public class. Non-access class modifiers - used in addition to access control. (below are valid combination) public_final, default_final public_abstract, default_final strictfp_final, public_strictfp, default_strictfp Final Classes - class can't be subclassed. Abstract Classes - can never be instantiated.","title":"Class Access(access a class)"},{"location":"java/#interface","text":"It is a contract for what a class can do, without saying anything about how the class will do it. Interface variables must be public, static and final = constants. Interface methods: must not be static. can extend only Interface(many). cannot implement another interface or class.","title":"Interface"},{"location":"java/#modifiers-on-member","text":"Access Modifiers: Public Members - all other classes can access the member. Private Members - can be accessed by code in which they are declared. Protected and Default Members - default member may be accessed only if the class accessing the member belongs to the same package, whereas a protected member can be accessed by a subclass. Default Members - package level. Nonaccess Member Modifiers: Final Methods - final keyword prevents the method from being overridden. Abstract Methods - declared but not implemented. Synchronized Methods - method can be accessed by only one thread at a time (applied only to methods). Native Methods - implemented in platform dependent code(like in C).","title":"Modifiers On Member"},{"location":"java/#variable-declarations","text":"Primitives - char, boolean, byte, short, int, long, double, float. Reference variables - used to refer (or access) an object. they can be static, instance variables, method parameters or local variables. Instance Variables : are defined inside class but outside any method, and are only initialized when class is instantiated. they are the fields that belong to each unique object. Array : objects that store multiple variables of the same type or variables that are all subclasses of the same type. can hold both primitives and object references. Final Variable : cannot be reinitialized (primitives) or reference variable cannot be changed but data within the object can be modified.(no final object only final references). Static variables and Methods : will exist independently of any instances created for the class (exist before we make instance of a class). one copy of static member exist regardless of number of instances of that class. static blocks are called before constructor. Enums : (java 5)> restrict a variable to have pre-defined value from an enumerated list. (items in the list are called enums). Enums can be declared as seperate class or class member but never within a method. ... Benefit of encapsulation - The ability to make changes in your implementation code without breaking the code of others who use your code. access methods - getters and setters(accessors and mutators). Hide implementation details behind a public programming interface, interface in the sense set of accessible methods your code makes available for other code to call - your code's API.","title":"Variable Declarations:"},{"location":"java/#inheritance-is-a-has-a","text":"instanceof operator: returns true if the reference variable being tested is of the type being compared to. every class is subclass of class Object. inheritance relationships can be created by extending a class. Reasons to use inheritance: To promote code reuse, To use polymorphism. code reuse - generic functionality (like method) don't have to be reimplemented, all subclasses are guaranteed to have capabilities of the superclass. polymorphism - treats any subclass of classA as classA, which allows you to write methods that don't need to change if new subclasses are created. Runtime polymorphism doesn't happen when static IS-A : based on class inheritance and interface implementation, \"this thing is a type of that thing\". HAS-A : based on usage, class A HAS-A B if code in class A has a reference to an instance of class B. Polymorphic method invocations apply only to instance methods, at runtime the only things that are dynamically selected based on the actual object are instance methods. Only overriden instance methods are dynamically invoked based on the real object's type. Overridden Methods - based on object type. Polymorphism lets you use a abstract supertype reference to refer to one of its subtypes. Overloading Methods - based on reference type. ... Coupling and Cohesion : good OO design calls for loose coupling and high cohesion. ... A primitive literal is merely a source code representation of primitive data types(eg:integer, floating-point number, boolean or character).","title":"Inheritance, Is-A, Has-A"},{"location":"java/#assignment","text":"Variables are bit Holders, with a designed type. A variable referring to an object is just that - a reference variable. A reference variable bit holder contains bits representing a way to get to the object.","title":"Assignment"},{"location":"java/#reification","text":"In computing, reification has come to mean an explicit representation of a type \u2014 that is, run-time type information. In Java, arrays reify information about their component types, while generic types do not reify information about their type parameters (while the type of a parameterized type is reified without its type parameters). In Java, we say that a type is reifiable if the type is completely represented at run time \u2014 that is, if erasure does not remove any useful information. To be precise, a type is reifiable if it is one of the following: A primitive type (such as int) A nonparameterized class or interface type (such as Number, String, or Runnable) A parameterized type in which all type arguments are unbounded wildcards (such as List<?>, ArrayList<?>, or Map<?, ?> ) A raw type (such as List, ArrayList, or Map) An array whose component type is reifiable (such as int[], Number[], List<?>[], List[], or int[][] ) A type is not reifiable if it is one of the following: A type variable (such as T) A parameterized type with actual parameters (such as List<Number> , ArrayList<String> , or Map<String, Integer> ) A parameterized type with a bound (such as List<? extends Number> or Comparable<? super String> ) So the type List<? extends Object> is not reifiable, even though it is equivalent to List<?> . Defining reifiable types in this way makes them easy to identify syntactically. Principle of Indecent Exposure: This principle guarantees that the component type at compile time will be a reifiable type. Based on above principle, never publicly expose an array where the components do not have a reifiable type. Principle of Truth in Advertising: This principle guarantees that the reified component type returned at run time must be a subtype of the reifiable component type declared at compile time. Converse to cast-iron guarantee, above principle illustrates if there are unchecked warnings, then casts inserted by erasure may fail.","title":"Reification"},{"location":"java/#generics","text":"In Java 5, the class Class has been made generic, and now has the form Class<T> . What does the T stand for? An instance of type Class<T> represents the type T. For example, String.class has type Class<String> . cast-iron guarantee: No cast inserted by erasure will fail, so long as there are no unchecked warnings. The Get and Put Principle: - use an extends wildcard when you only get values out of a structure - use a super wildcard when you only put values into a structure - don\u2019t use a wildcard when you both get and put. Why can't you create generic array type? Java's arrays (unlike generics) contain, at runtime, information about its component type. So you must know the component type when you create the array.","title":"Generics"},{"location":"java/#reflection","text":"Every type in Java, including primitive types and array types, has a class literal and a corresponding class token. generics for reflection: some of the types used for reflection are now generic types. reflection for generics: reflection now returns information about generic types. Class represents information about the type of an object at run time. The method getClass() is defined on every object and returns a class token that represents the reified type information carried by that object at run-time. class always represents a reifiable type, there is no point in parameterizing the class Class with a type that is not reifiable. Hence, the two main methods for producing a class with a type parameter, namely the getClass method and class literals, are both designed to yield a reifiable type for the type parameter in all cases. Each class token corresponds to a reifiable type. If you try to reflect a parameterized type, you get the reified information for the corresponding raw type.","title":"Reflection"},{"location":"java/#data-strucures","text":"Collections come in four basic flavors: Lists : Lists of things (classes that implement List) Sets : Unique things (classes that implement Set) Maps : Things with a unique ID (classes that implement Map) Queues : Things arranged by the order in which they are to be processed The core interfaces: The core concrete implementation classes: The interface and class hierarchy for collections: Arrays Arrays are objects in Java that store multiple variables of same type. Arrays can store either primitives or object references. List methods related to the index. eg:get(int index), indexof(Object o), add(int index, Object obj) ArrayList ordered collection implements RandomAccess, marker Interface supports fast random access Vector synchronized for thread safety implement RandomAccess LinkedList ordered by index position and also elements are doubly linked to one another choose this for implementing a stack or queue Set doesn't allow duplicates [using equals() method to determine identical objects] HashSet unsorted, unordered Set uses hashcode of the object being inserted LindkedHashset ordered and unsorted Set maintains doubly linked List across all elements iterates through the order in which they were inserted TreeSet Sorted Set elements will be in ascending order, according to natural order Map maps a unique key(ID) to a specific value can search for a valued based on the key uses equals() method to determine whether two keys are the same or different HashMap unsorted and unordered Map allows one null key and multiple null values in a collection LinkedHashMap maintains insertion order (optionally access order) faster iteration Hashtable doesn't allow any null can't synchronize class: only key methods of the class are synchronized TreeMap Sorted Map can define custom sort order(via a Comparable or Comparator) Queue holds things to be processed in some way Priority Queue to create \"priority-in, priority-out\" queue as opposed to FIFO ordered either by natural ordering or according to a Comparator","title":"Data Strucures"},{"location":"java/#comparable-interface","text":"A comparable object is capable of comparing itself with another object. Comparable provides compareTo() method to sort elements. Comparable affects the original class, i.e., the actual class is modified. Used by Collections.sort() and java.util.Arrays.sort() method.","title":"Comparable Interface:"},{"location":"java/#comparator-interface","text":"A comparator object is capable of comparing two different objects. It is not comparing its instances, but some other class's instances. Comparator provides compare() method to sort elements. Comparator doesn't affect the original class, i.e., the actual class is not modified.","title":"Comparator Interface"},{"location":"java/#developlment","text":"javac [options] [source files] java p[options] class [args]","title":"Developlment"},{"location":"java/#aop","text":"Join Point represents the effective execution of a method where the aspect will be applied. Advice is the action taken by an aspect at the particular Join Point. eg: Before, After, AfterReturning, AfterThrowing. Spring AOP may create chains of Advice for one single Join Point. Pointcut is a predicate that matches Join Point. An Advice is associated with a Pointcut expression and runs at any Join Point matching that Pointcut.","title":"AOP"},{"location":"java/#equality","text":"Often in Java programs you need to compare two objects to determine if they are equal or not. It turns out there are two different kinds of equality one can determine about objects in Java, reference equality or logical equality . Equality operator (==) compares the references (addresses in memory) of the two Strings as two different numbers - this is known as Reference Equality. Logical equality compares the data of the objects instead of the value of the references. Why, you might ask, did the String class override the equals method inherited from the Object class? Because the equals method inherited from Object performs reference equality! Here is what the implementation of the equals method in Object looks like: public boolean equals(Object other) { return this == other; } Notice that the parameter type is Object - it must be Object or you will have overloaded equals instead of overriding it.","title":"Equality"},{"location":"java/#inheritance-and-the-equals-method","text":"When overriding the equals method in classes making use of inheritance it is important to keep the super class and sub-class as loosely coupled as possible. Loosely coupled classes make as few assumptions about each other as possible making the code more maintainable over time. A secondary goal is to avoid duplication of code.","title":"Inheritance and the equals Method"},{"location":"java/#hashcode","text":"General Contracts for hashCode() in Java: If two objects are considered equal, their hashcodes must also be equal. Whenever the hashCode() method is invoked on the same object more than once within a single execution of the application, hashCode() must return the same integer provided no information or fields used in equals and hashcode is modified. If two objects are not equaled by equals() method it is not require that there hashcode must be different. Though it\u2019s always good practice to return different hashCode for unequal object. You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet and HashTable. Hashing retrieval is a two-step process: Find the right bucket...using hashCode() Search the bucket for the right element...using equals() Follow this for complete example...","title":"HashCode"},{"location":"java/#java-8","text":"","title":"Java 8"},{"location":"java/#functional-interfaces","text":"A functional interface has a single abstract method. Functional interfaces included with Java runtime. eg: Runnable, Callable, Comparator, TimerTask Prior to Java 8 it is known as Single Abstract Method (SAM) Types.","title":"Functional Interfaces"},{"location":"java/#method-references","text":"Method reference is used to refer method of functional interface. It is compact and easy form of lambda expression. Each time when you are using lambda expression to just referring a method, you can replace your lambda expression with method reference. Types of Method References Reference to a static method Reference to an instance method of a particular object or arbitrary object Reference to a constructor Details: 1. Reference to a Static Method You can refer to static method defined in the class. Following is the syntax and example which describe the process of referring static method in Java. ContainingClass::staticMethodName 2. Reference to an Instance Method like static methods, you can refer instance methods also containingObject::instanceMethodName 3. Reference to a Constructor You can refer a constructor by using the new keyword ClassName::new","title":"Method References"},{"location":"java/#optional","text":"Java 8 has introduced a new class Optional in java.util package. It is used to represent a value is present or absent. The main advantage of this new construct is that No more too many null checks. It avoids any runtime NullPointerExceptions and supports us in developing clean and neat Java APIs or Applications. Like Collections and arrays, it is also a Container to hold at most one value. Let us explore this new construct with some useful examples. Advantages of Java 8 Optional: Null checks are not required. No more NullPointerException at run-time. We can develop clean and neat APIs. No more Boiler plate code","title":"Optional"},{"location":"java/#lambda-expressions","text":"Lambda expressions can only appear in places where they will be assigned to a variable whose type is a functional interface. One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you're usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data. The previous section, Anonymous Classes, shows you how to implement a base class without giving it a name. Although this is often more concise than a named class, for classes with only one method, even an anonymous class seems a bit excessive and cumbersome. Lambda expressions let you express instances of single-method classes more compactly.","title":"Lambda Expressions"},{"location":"java/#hibernate","text":"Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map ther inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns.","title":"Hibernate"},{"location":"java/#maven","text":"Tool used for building and managing any Java-based project.","title":"Maven"},{"location":"java/#groupid","text":"It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins","title":"groupId"},{"location":"java/#artifactid","text":"It is the name of the jar without version. eg: maven","title":"artifactId"},{"location":"javascript/","text":"Javascript / Typescript Refer here for detailed examples","title":"JavaScript"},{"location":"javascript/#javascript-typescript","text":"Refer here for detailed examples","title":"Javascript / Typescript"},{"location":"nodeJS/","text":"NodeJS Follow here What is Node.js? Node.js is a runtime environment that allows you to run JavaScript code on the server-side, outside of a web browser. It is built on the V8 JavaScript engine, which is the same engine that powers Google Chrome, but it extends the capabilities of JavaScript by providing server-side APIs like file system access, network requests, and more. Key points about Node.js: Asynchronous and Event-driven: Node.js uses an event-driven, non-blocking I/O model, which makes it highly efficient, especially for I/O-intensive operations such as handling HTTP requests or interacting with databases. Instead of waiting for operations to complete, Node.js uses callbacks and events to handle multiple tasks concurrently. Single-threaded but Scalable: Despite being single-threaded, Node.js is designed to handle many concurrent requests using its non-blocking I/O model. It achieves scalability by using an event loop that efficiently manages asynchronous operations without the overhead of multiple threads. NPM (Node Package Manager): Node.js comes with a robust package ecosystem, NPM, which is the largest repository of open-source libraries and modules, allowing developers to easily integrate third-party code and tools into their projects. Use Cases: Node.js is commonly used for building real-time applications (like chat applications), RESTful APIs, streaming services, and microservices. It is particularly effective in handling applications that involve a lot of I/O, such as interacting with databases or external APIs. Explain event-driven programming in Node.js? Event-driven programming is a key concept in Node.js, and it refers to the design paradigm where the flow of a program is determined by events like user actions (clicks, keyboard inputs), messages, or system events (file I/O, HTTP requests). In Node.js, event-driven programming allows asynchronous, non-blocking execution, enabling the server to handle many connections concurrently without being tied up by long-running operations. Here\u2019s a breakdown of how event-driven programming works in Node.js: 1. Event Loop : At the core of Node.js is the event loop, which continuously monitors for incoming events or tasks. These events can be HTTP requests, file system operations, timers, or custom events. When an event occurs, the event loop triggers corresponding callback functions that were registered to handle those events. Blocking (Synchronous): If a function performs a task synchronously, it will block the event loop, meaning no other operations can be processed until the task is complete. Non-blocking (Asynchronous): In contrast, asynchronous operations are handled by the event loop without blocking it. Once the asynchronous task is complete, the event loop invokes the associated callback. 2. Event Emitter : Node.js has an EventEmitter class that helps in managing event-driven architecture. Any object that listens for events or triggers events is typically an instance of the EventEmitter class. You can attach listeners to events, and when the event occurs, Node.js invokes the corresponding callback. 3. Callbacks and Listeners : In an event-driven system, callbacks (also known as event handlers or listeners) are functions that are executed when a particular event occurs. When an asynchronous operation finishes, a callback function is executed, which allows Node.js to continue running other operations while waiting for the event to occur. How it works: Registering a listener: You attach a function (callback) to an event. This function will be executed whenever the event is emitted. Emitting an event: When the event occurs (e.g., an HTTP request is received), the event emitter \"emits\" the event, triggering any attached listeners. 4. Advantages of Event-driven Programming in Node.js : Non-blocking I/O: This is particularly useful in scenarios where you have I/O-heavy operations (like reading files, querying databases) because the event loop doesn't wait for these operations to complete before moving on to handle other tasks. Scalability: Since Node.js doesn\u2019t block the execution thread for I/O operations, it can handle a large number of concurrent connections with minimal overhead. Efficiency: Event-driven programming helps utilize system resources efficiently, especially in handling real-time applications, chat applications, or APIs that involve many simultaneous users or connections. What is the difference between require() and import in Node.js? 1. Module Systems : require() : This is the standard way of importing modules in Node.js using the CommonJS module system. It has been in use since the early days of Node.js. require() is dynamic, meaning it can be called conditionally, at any point in the code. This allows you to load modules at runtime. import : This is part of the ES6 (ECMAScript 2015) standard, also known as the ESM (ECMAScript Module) system, which was introduced later and is now supported in modern JavaScript environments, including Node.js (since version 12+ with certain configurations). import is static, meaning it must be called at the top level of the module and cannot be conditionally imported. All imports are resolved at the start of the program.","title":"NodeJS"},{"location":"nodeJS/#nodejs","text":"Follow here","title":"NodeJS"},{"location":"nodeJS/#what-is-nodejs","text":"Node.js is a runtime environment that allows you to run JavaScript code on the server-side, outside of a web browser. It is built on the V8 JavaScript engine, which is the same engine that powers Google Chrome, but it extends the capabilities of JavaScript by providing server-side APIs like file system access, network requests, and more. Key points about Node.js: Asynchronous and Event-driven: Node.js uses an event-driven, non-blocking I/O model, which makes it highly efficient, especially for I/O-intensive operations such as handling HTTP requests or interacting with databases. Instead of waiting for operations to complete, Node.js uses callbacks and events to handle multiple tasks concurrently. Single-threaded but Scalable: Despite being single-threaded, Node.js is designed to handle many concurrent requests using its non-blocking I/O model. It achieves scalability by using an event loop that efficiently manages asynchronous operations without the overhead of multiple threads. NPM (Node Package Manager): Node.js comes with a robust package ecosystem, NPM, which is the largest repository of open-source libraries and modules, allowing developers to easily integrate third-party code and tools into their projects. Use Cases: Node.js is commonly used for building real-time applications (like chat applications), RESTful APIs, streaming services, and microservices. It is particularly effective in handling applications that involve a lot of I/O, such as interacting with databases or external APIs.","title":"What is Node.js?"},{"location":"nodeJS/#explain-event-driven-programming-in-nodejs","text":"Event-driven programming is a key concept in Node.js, and it refers to the design paradigm where the flow of a program is determined by events like user actions (clicks, keyboard inputs), messages, or system events (file I/O, HTTP requests). In Node.js, event-driven programming allows asynchronous, non-blocking execution, enabling the server to handle many connections concurrently without being tied up by long-running operations. Here\u2019s a breakdown of how event-driven programming works in Node.js: 1. Event Loop : At the core of Node.js is the event loop, which continuously monitors for incoming events or tasks. These events can be HTTP requests, file system operations, timers, or custom events. When an event occurs, the event loop triggers corresponding callback functions that were registered to handle those events. Blocking (Synchronous): If a function performs a task synchronously, it will block the event loop, meaning no other operations can be processed until the task is complete. Non-blocking (Asynchronous): In contrast, asynchronous operations are handled by the event loop without blocking it. Once the asynchronous task is complete, the event loop invokes the associated callback. 2. Event Emitter : Node.js has an EventEmitter class that helps in managing event-driven architecture. Any object that listens for events or triggers events is typically an instance of the EventEmitter class. You can attach listeners to events, and when the event occurs, Node.js invokes the corresponding callback. 3. Callbacks and Listeners : In an event-driven system, callbacks (also known as event handlers or listeners) are functions that are executed when a particular event occurs. When an asynchronous operation finishes, a callback function is executed, which allows Node.js to continue running other operations while waiting for the event to occur. How it works: Registering a listener: You attach a function (callback) to an event. This function will be executed whenever the event is emitted. Emitting an event: When the event occurs (e.g., an HTTP request is received), the event emitter \"emits\" the event, triggering any attached listeners. 4. Advantages of Event-driven Programming in Node.js : Non-blocking I/O: This is particularly useful in scenarios where you have I/O-heavy operations (like reading files, querying databases) because the event loop doesn't wait for these operations to complete before moving on to handle other tasks. Scalability: Since Node.js doesn\u2019t block the execution thread for I/O operations, it can handle a large number of concurrent connections with minimal overhead. Efficiency: Event-driven programming helps utilize system resources efficiently, especially in handling real-time applications, chat applications, or APIs that involve many simultaneous users or connections.","title":"Explain event-driven programming in Node.js?"},{"location":"nodeJS/#what-is-the-difference-between-require-and-import-in-nodejs","text":"1. Module Systems : require() : This is the standard way of importing modules in Node.js using the CommonJS module system. It has been in use since the early days of Node.js. require() is dynamic, meaning it can be called conditionally, at any point in the code. This allows you to load modules at runtime. import : This is part of the ES6 (ECMAScript 2015) standard, also known as the ESM (ECMAScript Module) system, which was introduced later and is now supported in modern JavaScript environments, including Node.js (since version 12+ with certain configurations). import is static, meaning it must be called at the top level of the module and cannot be conditionally imported. All imports are resolved at the start of the program.","title":"What is the difference between require() and import in Node.js?"},{"location":"reactJS/","text":"What is React? React is a JavaScript library developed by Facebook for building user interfaces, especially single-page applications. It is component-based, allows the development of reusable UI components, and helps in creating dynamic web apps with great performance. What are the key features of React? Virtual DOM: Optimizes updates by re-rendering only what\u2019s necessary. Component-based architecture: Breaks UI into reusable pieces. One-way data binding: Data flows in one direction (from parent to child components). JSX: A syntax extension that allows writing HTML in JavaScript. Declarative UI: Developers describe what UI should look like. What is JSX? JSX stands for JavaScript XML. It allows writing HTML-like syntax in JavaScript code. Browsers don\u2019t understand JSX directly, so it\u2019s compiled into regular JavaScript using tools like Babel. You can embed any JavaScript expression in JSX by wrapping it in curly braces. After compilation, JSX expressions become regular JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions What are components in React? Components are the building blocks of a React application. They allow splitting the UI into independent, reusable pieces. There are two types: Class Components: ES6 classes that extend React.Component and use lifecycle methods. Functional Components: JavaScript functions that return JSX and use hooks for managing state and lifecycle. What is the Virtual DOM? How does it work? The Virtual DOM is a lightweight in-memory representation of the actual DOM. React updates the Virtual DOM first, calculates the differences (diffing), and then updates the real DOM only where necessary. This minimizes direct DOM manipulations, improving performance. What are props in React? Props (short for properties) are read-only attributes passed from a parent component to a child component. They allow passing data and methods between components. What is state in React? State is a built-in React object used to store data or information about the component. Unlike props, state is mutable and managed within the component. When state changes, React re-renders the component. What are hooks in React? Hooks are special functions that allow using state and other React features in functional components. The most commonly used hooks are: useState for state management. useEffect for managing side effects like API calls, timers, etc. useContext for accessing React context. useMemo and useCallback for optimizing performance. What is the difference between state and props? Props are passed from parent to child components, are immutable, and allow sharing data across components. State is local to the component, mutable, and used to manage internal data that can change over time. What is the purpose of useEffect in React? useEffect is a hook used to perform side effects in functional components, like fetching data, updating the DOM, or setting up subscriptions. It runs after the render cycle and can optionally clean up after itself by returning a function. What is the purpose of keys in React? Keys help React identify which items in a list have changed, are added, or are removed. This improves the efficiency of updating the DOM and is crucial when rendering lists of components. What are higher-order components (HOC) in React? A HOC is a pattern in which a function takes a component and returns a new component with added functionality. It's a way to reuse component logic. For example, adding authentication checks to multiple components. What is the Context API in React? The Context API allows for sharing state and functions across multiple components without passing props down manually at every level. It is particularly useful for managing global state like themes, user sessions, etc. What is lazy loading in React? Lazy loading in React is a way to defer loading components until they are needed, improving the initial load time. React provides React.lazy() and Suspense for implementing lazy loading. What are React portals? React portals provide a way to render components outside the main DOM hierarchy. They are useful for rendering modals, tooltips, or popups that require being placed at the root level of the DOM. What is the difference between controlled and uncontrolled components? Controlled components are those whose form data is handled by the React component state. Input elements like <input> , <textarea> , and <select> are controlled by the component's state using the onChange event handler. Uncontrolled components use refs to directly access the DOM element\u2019s values. What is the useReducer hook? useReducer is an alternative to useState when managing more complex state logic. It accepts a reducer function (state, action) and an initial state and returns the current state paired with a dispatch method to trigger state updates. What is memoization in React? Memoization is an optimization technique used to speed up rendering by caching results. React provides React.memo and hooks like useMemo and useCallback to avoid unnecessary re-renders and expensive computations. What is the difference between useMemo and useCallback? useMemo: Returns a memoized value, used to optimize expensive computations. useCallback: Returns a memoized function reference, useful when passing functions as props to child components to prevent re-renders. How can you improve the performance of a React app? Use React's memoization (React.memo, useMemo, useCallback). Use Code Splitting and Lazy Loading. Avoid anonymous functions in render. Implement shouldComponentUpdate or use PureComponent. Optimize re-rendering by managing state efficiently. Use React Profiler to identify performance bottlenecks. What is Redux, and how does it relate to React? Redux is a state management library that can be used with React (or other frameworks). It provides a central store for managing application state and follows a unidirectional data flow. In React, it's typically used with the react-redux library for binding the store with React components. What is the difference between Redux and Context API? Both Redux and the Context API solve similar problems: sharing state across components. However: Redux is more powerful for complex state management, providing middlewares, actions, reducers, and a strict structure. Context API is simpler and suitable for smaller apps with less complex state needs. What is React Router? React Router is a popular routing library for React. It allows for dynamic routing, enabling navigation between different views or components in a single-page application without refreshing the page. What are render props? Render props is a technique for sharing code between React components using a prop whose value is a function. It allows for more dynamic and reusable components. How do you handle forms in React? In React, forms can be handled using: Controlled components, where form elements are bound to the state and update via onChange handlers. Uncontrolled components, using refs to access form values directly from the DOM. How React Works Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it\u2019s done faster than it would be in the regular DOM. For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent. Redux Redux enforces keeping all state in a single centralized object graph. A callback function can be invoked when setState has finished and the component is re-rendered. Since the setState is asynchronous, which is why it takes in a second callback function. With this function, we can do what we want immediately after state has been updated. React: Someone clicked this 'Save' button. Action: Actions are payloads of information that send data from our application to our store. They are the only source of information for the store. We send them to the store using store.dispatch(). Primarly, they are just an object describes what happened in our app. Reducer: Reducers specify how the application\u2019s state changes in response to actions sent to the store. Remember that actions only describe what happened, but don\u2019t describe how the application\u2019s state changes. So this place determines how state will change to an action. Store: The Store is the object that brings Action and Reducer together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener); Handles unregistering of listeners via the function returned by subscribe(listener). React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this. Reducers are functions that take the current state in an action and then return a new state. setState() actions are asynchronous and are batched for performance gains. This is explained in documentation as below. setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains. This is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. Thus the setState calls are asynchronous as well as batched for better UI experience and performance. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children } Questions What are controlled and uncontrolled components in React? This relates to stateful DOM components (form elements) and the difference: In HTML, form elements such as <input> , <textarea> , and <select> typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g. onChange is fired as the state will be updated. A form element whose value is controlled by React in this way is called a \"controlled component\". With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component \u201ccontrols\u201d it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a \u201cdumb component\u201d. A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML. In most (or all) cases we should use controlled components. What is render() in React? And explain its purpose? Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <form> , <group> , <div> etc. This function must be kept pure i.e., it must return the same result each time it is invoked. What is React.cloneElement? And the difference with this.props.children? React.cloneElement clone and return a new React element using using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved. React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element. How Virtual-DOM is more efficient than Dirty checking? In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering. The virtual DOM is used for efficient re-rendering of the DOM. This isn\u2019t really related to dirty checking your data. We could re-render using a virtual DOM with or without dirty checking. In fact, the diff algorithm is a dirty checker itself. We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing. What is PureComponent? When to use PureComponent over Component? PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for us. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called. When comparing previous props and state to next, a shallow comparison will check that primitives have the same value (eg, 1 equals 1 or that true equals true) and that the references are the same between more complex javascript values like objects and arrays. It is good to prefer PureComponent over Component whenever we never mutate our objects. What is a higher order component? A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API. They are a pattern that emerges from React\u2019s compositional nature. A higher-order component is a function that takes a component and returns a new component. HOC\u2019s allow you to reuse code, logic and bootstrap abstraction. HOCs are common in third-party React libraries. The most common is probably Redux\u2019s connect function. Beyond simply sharing utility libraries and simple composition, HOCs are the best way to share behavior between React Components. If you find yourself writing a lot of code in different places that does the same thing, you may be able to refactor that code into a reusable HOC. What are the differences between a class component and functional component? Class components allows us to use additional features such as local state and lifecycle hooks. Also, to enable our component to have direct access to our store and thus holds state. When our component just receives props and renders them to the page, this is a \u2018stateless component\u2019, for which a pure function can be used. These are also called dumb components or presentational components.","title":"ReactJS"},{"location":"reactJS/#what-is-react","text":"React is a JavaScript library developed by Facebook for building user interfaces, especially single-page applications. It is component-based, allows the development of reusable UI components, and helps in creating dynamic web apps with great performance.","title":"What is React?"},{"location":"reactJS/#what-are-the-key-features-of-react","text":"Virtual DOM: Optimizes updates by re-rendering only what\u2019s necessary. Component-based architecture: Breaks UI into reusable pieces. One-way data binding: Data flows in one direction (from parent to child components). JSX: A syntax extension that allows writing HTML in JavaScript. Declarative UI: Developers describe what UI should look like.","title":"What are the key features of React?"},{"location":"reactJS/#what-is-jsx","text":"JSX stands for JavaScript XML. It allows writing HTML-like syntax in JavaScript code. Browsers don\u2019t understand JSX directly, so it\u2019s compiled into regular JavaScript using tools like Babel. You can embed any JavaScript expression in JSX by wrapping it in curly braces. After compilation, JSX expressions become regular JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions","title":"What is JSX?"},{"location":"reactJS/#what-are-components-in-react","text":"Components are the building blocks of a React application. They allow splitting the UI into independent, reusable pieces. There are two types: Class Components: ES6 classes that extend React.Component and use lifecycle methods. Functional Components: JavaScript functions that return JSX and use hooks for managing state and lifecycle.","title":"What are components in React?"},{"location":"reactJS/#what-is-the-virtual-dom-how-does-it-work","text":"The Virtual DOM is a lightweight in-memory representation of the actual DOM. React updates the Virtual DOM first, calculates the differences (diffing), and then updates the real DOM only where necessary. This minimizes direct DOM manipulations, improving performance.","title":"What is the Virtual DOM? How does it work?"},{"location":"reactJS/#what-are-props-in-react","text":"Props (short for properties) are read-only attributes passed from a parent component to a child component. They allow passing data and methods between components.","title":"What are props in React?"},{"location":"reactJS/#what-is-state-in-react","text":"State is a built-in React object used to store data or information about the component. Unlike props, state is mutable and managed within the component. When state changes, React re-renders the component.","title":"What is state in React?"},{"location":"reactJS/#what-are-hooks-in-react","text":"Hooks are special functions that allow using state and other React features in functional components. The most commonly used hooks are: useState for state management. useEffect for managing side effects like API calls, timers, etc. useContext for accessing React context. useMemo and useCallback for optimizing performance.","title":"What are hooks in React?"},{"location":"reactJS/#what-is-the-difference-between-state-and-props","text":"Props are passed from parent to child components, are immutable, and allow sharing data across components. State is local to the component, mutable, and used to manage internal data that can change over time.","title":"What is the difference between state and props?"},{"location":"reactJS/#what-is-the-purpose-of-useeffect-in-react","text":"useEffect is a hook used to perform side effects in functional components, like fetching data, updating the DOM, or setting up subscriptions. It runs after the render cycle and can optionally clean up after itself by returning a function.","title":"What is the purpose of useEffect in React?"},{"location":"reactJS/#what-is-the-purpose-of-keys-in-react","text":"Keys help React identify which items in a list have changed, are added, or are removed. This improves the efficiency of updating the DOM and is crucial when rendering lists of components.","title":"What is the purpose of keys in React?"},{"location":"reactJS/#what-are-higher-order-components-hoc-in-react","text":"A HOC is a pattern in which a function takes a component and returns a new component with added functionality. It's a way to reuse component logic. For example, adding authentication checks to multiple components.","title":"What are higher-order components (HOC) in React?"},{"location":"reactJS/#what-is-the-context-api-in-react","text":"The Context API allows for sharing state and functions across multiple components without passing props down manually at every level. It is particularly useful for managing global state like themes, user sessions, etc.","title":"What is the Context API in React?"},{"location":"reactJS/#what-is-lazy-loading-in-react","text":"Lazy loading in React is a way to defer loading components until they are needed, improving the initial load time. React provides React.lazy() and Suspense for implementing lazy loading.","title":"What is lazy loading in React?"},{"location":"reactJS/#what-are-react-portals","text":"React portals provide a way to render components outside the main DOM hierarchy. They are useful for rendering modals, tooltips, or popups that require being placed at the root level of the DOM.","title":"What are React portals?"},{"location":"reactJS/#what-is-the-difference-between-controlled-and-uncontrolled-components","text":"Controlled components are those whose form data is handled by the React component state. Input elements like <input> , <textarea> , and <select> are controlled by the component's state using the onChange event handler. Uncontrolled components use refs to directly access the DOM element\u2019s values.","title":"What is the difference between controlled and uncontrolled components?"},{"location":"reactJS/#what-is-the-usereducer-hook","text":"useReducer is an alternative to useState when managing more complex state logic. It accepts a reducer function (state, action) and an initial state and returns the current state paired with a dispatch method to trigger state updates.","title":"What is the useReducer hook?"},{"location":"reactJS/#what-is-memoization-in-react","text":"Memoization is an optimization technique used to speed up rendering by caching results. React provides React.memo and hooks like useMemo and useCallback to avoid unnecessary re-renders and expensive computations.","title":"What is memoization in React?"},{"location":"reactJS/#what-is-the-difference-between-usememo-and-usecallback","text":"useMemo: Returns a memoized value, used to optimize expensive computations. useCallback: Returns a memoized function reference, useful when passing functions as props to child components to prevent re-renders.","title":"What is the difference between useMemo and useCallback?"},{"location":"reactJS/#how-can-you-improve-the-performance-of-a-react-app","text":"Use React's memoization (React.memo, useMemo, useCallback). Use Code Splitting and Lazy Loading. Avoid anonymous functions in render. Implement shouldComponentUpdate or use PureComponent. Optimize re-rendering by managing state efficiently. Use React Profiler to identify performance bottlenecks.","title":"How can you improve the performance of a React app?"},{"location":"reactJS/#what-is-redux-and-how-does-it-relate-to-react","text":"Redux is a state management library that can be used with React (or other frameworks). It provides a central store for managing application state and follows a unidirectional data flow. In React, it's typically used with the react-redux library for binding the store with React components.","title":"What is Redux, and how does it relate to React?"},{"location":"reactJS/#what-is-the-difference-between-redux-and-context-api","text":"Both Redux and the Context API solve similar problems: sharing state across components. However: Redux is more powerful for complex state management, providing middlewares, actions, reducers, and a strict structure. Context API is simpler and suitable for smaller apps with less complex state needs.","title":"What is the difference between Redux and Context API?"},{"location":"reactJS/#what-is-react-router","text":"React Router is a popular routing library for React. It allows for dynamic routing, enabling navigation between different views or components in a single-page application without refreshing the page.","title":"What is React Router?"},{"location":"reactJS/#what-are-render-props","text":"Render props is a technique for sharing code between React components using a prop whose value is a function. It allows for more dynamic and reusable components.","title":"What are render props?"},{"location":"reactJS/#how-do-you-handle-forms-in-react","text":"In React, forms can be handled using: Controlled components, where form elements are bound to the state and update via onChange handlers. Uncontrolled components, using refs to access form values directly from the DOM.","title":"How do you handle forms in React?"},{"location":"reactJS/#how-react-works","text":"Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it\u2019s done faster than it would be in the regular DOM. For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent.","title":"How React Works"},{"location":"reactJS/#redux","text":"Redux enforces keeping all state in a single centralized object graph. A callback function can be invoked when setState has finished and the component is re-rendered. Since the setState is asynchronous, which is why it takes in a second callback function. With this function, we can do what we want immediately after state has been updated. React: Someone clicked this 'Save' button. Action: Actions are payloads of information that send data from our application to our store. They are the only source of information for the store. We send them to the store using store.dispatch(). Primarly, they are just an object describes what happened in our app. Reducer: Reducers specify how the application\u2019s state changes in response to actions sent to the store. Remember that actions only describe what happened, but don\u2019t describe how the application\u2019s state changes. So this place determines how state will change to an action. Store: The Store is the object that brings Action and Reducer together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener); Handles unregistering of listeners via the function returned by subscribe(listener). React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this. Reducers are functions that take the current state in an action and then return a new state. setState() actions are asynchronous and are batched for performance gains. This is explained in documentation as below. setState() does not immediately mutate this.state but creates a pending state transition. Accessing this.state after calling this method can potentially return the existing value. There is no guarantee of synchronous operation of calls to setState and calls may be batched for performance gains. This is because setState alters the state and causes rerendering. This can be an expensive operation and making it synchronous might leave the browser unresponsive. Thus the setState calls are asynchronous as well as batched for better UI experience and performance. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children }","title":"Redux"},{"location":"reactJS/#questions","text":"What are controlled and uncontrolled components in React? This relates to stateful DOM components (form elements) and the difference: In HTML, form elements such as <input> , <textarea> , and <select> typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g. onChange is fired as the state will be updated. A form element whose value is controlled by React in this way is called a \"controlled component\". With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component \u201ccontrols\u201d it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a \u201cdumb component\u201d. A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML. In most (or all) cases we should use controlled components. What is render() in React? And explain its purpose? Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <form> , <group> , <div> etc. This function must be kept pure i.e., it must return the same result each time it is invoked. What is React.cloneElement? And the difference with this.props.children? React.cloneElement clone and return a new React element using using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved. React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element. How Virtual-DOM is more efficient than Dirty checking? In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering. The virtual DOM is used for efficient re-rendering of the DOM. This isn\u2019t really related to dirty checking your data. We could re-render using a virtual DOM with or without dirty checking. In fact, the diff algorithm is a dirty checker itself. We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing. What is PureComponent? When to use PureComponent over Component? PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for us. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called. When comparing previous props and state to next, a shallow comparison will check that primitives have the same value (eg, 1 equals 1 or that true equals true) and that the references are the same between more complex javascript values like objects and arrays. It is good to prefer PureComponent over Component whenever we never mutate our objects. What is a higher order component? A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API. They are a pattern that emerges from React\u2019s compositional nature. A higher-order component is a function that takes a component and returns a new component. HOC\u2019s allow you to reuse code, logic and bootstrap abstraction. HOCs are common in third-party React libraries. The most common is probably Redux\u2019s connect function. Beyond simply sharing utility libraries and simple composition, HOCs are the best way to share behavior between React Components. If you find yourself writing a lot of code in different places that does the same thing, you may be able to refactor that code into a reusable HOC. What are the differences between a class component and functional component? Class components allows us to use additional features such as local state and lifecycle hooks. Also, to enable our component to have direct access to our store and thus holds state. When our component just receives props and renders them to the page, this is a \u2018stateless component\u2019, for which a pure function can be used. These are also called dumb components or presentational components.","title":"Questions"}]}
{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Data Structure Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks. Linear Data Structures Array It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n) LinkedList SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) Stack (LIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces Queue (FIFO) Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO Hierarchical Data Structure Binary Tree A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: The maximum number of nodes at level l = 2^(l-1) Maximum number of nodes, where h $\\to$ height of the tree 2^h-1 eg: They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories. Binary Search Tree A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList. Graph It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network. TRIE (Digital Tree or Radix Tree or Prefix Tree) It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M). Time Complexity It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity. Sorting Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n) In-place Sorting The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure. External Sorting Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations Searching Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"About"},{"location":"#data-structure","text":"Is is a particular way of organising data in a computer so that it can be used effectively. The idea is to reduce the space and time complexity of different tasks.","title":"Data Structure"},{"location":"#linear-data-structures","text":"","title":"Linear Data Structures"},{"location":"#array","text":"It is a data structure used to store homogeneous elements at contiguous locations, size of an array must be provided before storing data. Insertion \\rightarrow O(n) Deletion \\rightarrow O(n) Access \\rightarrow O(1) Search \\rightarrow O(n)","title":"Array"},{"location":"#linkedlist","text":"SinglyLinkedList DoublyLinkedList Random access in not allowed. Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n)","title":"LinkedList"},{"location":"#stack-lifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: DFS Reverse a word Undo Back/Forward on browsers Matching braces","title":"Stack (LIFO)"},{"location":"#queue-fifo","text":"Insertion \\rightarrow O(1) Deletion \\rightarrow O(1) Access \\rightarrow O(n) eg: CPU scheduling BFS When data is transferred asynchronously between two processes i.e IO Buffers, pipes, file IO","title":"Queue (FIFO)"},{"location":"#hierarchical-data-structure","text":"","title":"Hierarchical Data Structure"},{"location":"#binary-tree","text":"A binary tree has each node having at most two children, which are referred to as the left child and the right child. A tree is represented by a pointer to the topmost node in tree. A node contains: Data Pointer to left child Pointer to right child A Binary Tree can be traversed in two ways: Depth First Traversal Breadth First Traversal Properties: The maximum number of nodes at level l = 2^(l-1) Maximum number of nodes, where h $\\to$ height of the tree 2^h-1 eg: They are useful in File Structures where each file is located in a particular directory and there is a specific hierarchy associated with file and directories.","title":"Binary Tree"},{"location":"#binary-search-tree","text":"A tree with following additional properties: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. The left and right subtree each must also be a binary search tree. Time Complexity of BST: Search \\rightarrow O(h) Insertion \\rightarrow O(h) Deletion \\rightarrow O(h) h -> O(log n) if height balanced Access/Search quicker than LinkedList and slower than Array. Insertion/Deletion quicker than Arrays and slower than LinkedList.","title":"Binary Search Tree"},{"location":"#graph","text":"It consists of following two components: A finite set of vertices also called as nodes A finite set of ordered pair of the form (u,v) called as edge. The pair is ordered because (u,v) is not same as (v,u) in case of directed graph. The pair of the form (u,v) indicates that there is an edge vertex u to vertex v. The edges may contain weight/value/cost. V -> number of vertices E -> number of Edges Direction: Undirected Graph Directed Graph Weight: Weighted Graph Unweighted Graph eg: The graph is used to find shortest path in any network.","title":"Graph"},{"location":"#trie-digital-tree-or-radix-tree-or-prefix-tree","text":"It is the efficient information retrieval data structure. If we store keys in BST, a well balanced BST will need time proportional to M * log N where M is max string length and N is number of keys in tree, using TRIE search will take O(M).","title":"TRIE (Digital Tree or Radix Tree or Prefix Tree)"},{"location":"#time-complexity","text":"It is the computational complexity that measures or estimates the time taken for running an algorithm. It is commonly estimated by counting the number of elementary operations performed by the algorithm, supposing that an elementary operation takes a fixed amount of time to perform. Thus, the amount of time taken and the number of elementary operations performed by the algorithm differ by at most a constant factor. Since an algorightm's running time may vary with different inputs of the same size, one commonly considers the worst-case time complexity, which is the maximum amount of time taken on inputs of a given size. Time complexity is generally expressed as a function of the size of the input. One commonly focuses on the behavior of the complexity when the input size increases. i.e on the asympototic behavior of the complexity.","title":"Time Complexity"},{"location":"#sorting","text":"Algorithm Worst Selection Sort O(n^2) Bubble Sort O(n^2) Insertion Sort O(n^2) Merge Sort O(n log n) Quick Sort O(n^2) Heap Sort O(n log n)","title":"Sorting"},{"location":"#in-place-sorting","text":"The input is usually overwritten by the output as the algorithm executes (through replacement or swapping of elements). Space Complexity is O(log n). eg: Selection Sort, Bubble Sort, Insertion Sort, Heap Sort Heap Sort is a comparison based sorting technique based on Binary Heap data structure.","title":"In-place Sorting"},{"location":"#external-sorting","text":"Used when all data that needs to be sorted cannot be placed in memory at a time, it is used for massive amount of data. eg: Merge Sort and its variations","title":"External Sorting"},{"location":"#searching","text":"Linear Search : A sequential search is made over all items one by one. The Time Complexity is O(n1). Binary Search : The data should be in the sorted form. Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty. Time Complexity is O(log n).","title":"Searching"},{"location":"angular/","text":"Angular Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes. Modules NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules. NgModule metadata NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property. NgModules and components NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule. Architecture overview Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views. Data Binding A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name. Pipes Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p> Directives Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent Routing The Angular router enables navigation from one view to the next as users perfrom application tasks. Forms Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Angular"},{"location":"angular/#angular","text":"Angular is a framework for building client applications in HTML. The framework consists of several libraries. The angular application is written by composing HTML templates with angularized markup, writing component classes to manage those templates, adding applications logic in services, and boxing components & services in modules. Angular apps are modular and Angular has its own modularity system called NgModules eg: AppModule: which is the root module, @NgModule decorator. Decorators are functions that modify Javascript classes. eg: @Input, @Output Angular has many decorators that attach metadata to classes.","title":"Angular"},{"location":"angular/#modules","text":"NgModules are containers for a cohesive block of code dedicated to an application domain, a workflow, or a closely related set of capabilities. They can contain components, service providers, and other code files whose scope is defined by the containing NgModule. They can import functionality that is exported from other NgModules, and export selected functionality for use by other NgModules.","title":"Modules"},{"location":"angular/#ngmodule-metadata","text":"NgModule is a decorator function that takes a single metadata object whose properties describe the module, such as declarations: the view classes that belong to this module. Angular has three kinds of view classes - components, directives and pipes. exports: the subset of declarations that should be visible & usable in the component templates of other modules. imports: other modules whose exported classes are needed by component templates declared in this module. providers: creators of service that this module contributes to the global collection of services; they become accessible in all parts of the app. bootstrap: The main application view, called the root component, which hosts all other app views. Only the root NgModule should set the bootstrap property.","title":"NgModule metadata"},{"location":"angular/#ngmodules-and-components","text":"NgModules provide a compilation context for their components. A root NgModule always has a root component that is created during bootstrap, but any NgModule can include any number of additional components, which can be loaded through the router or created through the template. The components that belong to an NgModule share a compilation context. A component and its template together define a view. A component can contain a view hierarchy, which allows you to define arbitrarily complex areas of the screen that can be created, modified, and destroyed as a unit. A view hierarchy can mix views defined in components that belong to different NgModules. This is often the case, especially for UI libraries. When you create a component, it's associated directly with a single view, called the host view. The host view can be the root of a view hierarchy, which can contain embedded views, which are in turn the host views of other components. Those components can be in the same NgModule, or can be imported from other NgModules. Views in the tree can be nested to any depth. Views are typically arranged hierarchically, allowing you to modify or show and hide entire UI sections or pages as a unit. The template immediately associated with a component defines that component's host view. The component can also define a view hierarchy, which contains embedded views, hosted by other components. A view hierarchy can include views from components in the same NgModule.","title":"NgModules and components"},{"location":"angular/#architecture-overview","text":"Angular ships with a collection of js modules, you can think of them as library modules. eg:import Angular's Component decorator from the @angular/core library using import { Component } from '@angular/core'; . Component: A component controls a patch of screen called a view. You define a components application logic; what it does to support the view inside a class. The class interacts with the view through an API of properties and methods. Templates: You define a components view with its companion template, A template is a form of HTML that tells Angualr how to render the component. Metadata tells Angular how to process a class. In Typescript, you attach metadata by using a decorator. Service is a class that performs a specific task eg: fetching data from backend or logging service. Angular uses dependency injection to provide new components with the services they need, such as the router service that lets you define navigation among views.","title":"Architecture overview"},{"location":"angular/#data-binding","text":"A mechanism for coordinating parts of a template with parts of a component. The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from the DOM, or both. Data binding between a template and its component: Data binding between parent and child coponents: <li>{{hero.name}}</li> <app-hero-detail [hero]=\"selectedHero\"></app-hero-detail> <li (click)=\"selectHero(hero)\"></li> The {{hero.name}} interpolation displays the component's hero.name property value. The [hero] property binding passes the value of selectedHero from the parent HeroListComponent to the hero property of the child HeroDetailComponent. The (click) event binding calls the component's selectHero method when the user clicks a hero's name.","title":"Data Binding"},{"location":"angular/#pipes","text":"Angular pipes let you declare display-value transformations in your template HTML. A class with the @Pipe decorator defines a function that transforms input values to output values for display in a view. eg: {{interpolated_value | pipe_name}}...<p>Today is {{today | date}}</p>","title":"Pipes"},{"location":"angular/#directives","text":"Angular templates are dynamic, when Angular renders them, it transforms the DOM according to the instructions given by directives. A component is a directive-with-a-template. Structural directive alter layout by adding, removing and replacing elements of DOM. eg: *ngFor, *ngIf Attribute directive alter the appearance or behavior of an existing element. eg: [(ngModel)] custom directive eg: HeroListComponent","title":"Directives"},{"location":"angular/#routing","text":"The Angular router enables navigation from one view to the next as users perfrom application tasks.","title":"Routing"},{"location":"angular/#forms","text":"Template-Driven: Angular infers the form object from the DOM Reactive: Form is created programmatically & synchronized withe the DOM","title":"Forms"},{"location":"java/","text":"groupId It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins artifactId It is the name of the jar without version. eg: maven Hibernate Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map their inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns.","title":"Java"},{"location":"java/#groupid","text":"It identify your project uniquely across all projects, It has to follow the package name rules. eg: org.apache.maven A good way to determine the granularity of the groupId is to use the project structure. That is, if the current project is a multiple module project, it should append a new identifier to the parent's groupId. eg: org.apache.maven.plugins","title":"groupId"},{"location":"java/#artifactid","text":"It is the name of the jar without version. eg: maven","title":"artifactId"},{"location":"java/#hibernate","text":"Hibernate is an open-source and lightweight ORM tool that is used to store, manipulate and retrieve data from the database. ORM -> Object Relational Mapping Its is a programming strategy to map object with the data stored in the database. Hibernate architecture comprises of many interfaces such as: Configuration SessionFactory Session Transaction...etc (Query, Criteria) SessionFactory provides the instance of Session: It is a factory of Session It holds the data of second level cache that is not enabled by default It is a thread safe object Session maintains a connection beetween hibernate application and database: It provides methods to store, update, delete or fetch data from the database such as persist(), update(), delete(), load(), get() etc It is a factory of Query, Criteria and Transaction. It provides factory methods to return these instances It is not thread safe 3 states of object (instance): Transient : Th object is in transient state if it is just created but has no primary key (identifier) and not associated with session. Peristent : The object is in persistent state if session is open, and you just saved the instance in the database or retreived the instance from the database. Detached : The object is in detached state if session is closed. After detached state, object comes to persistent state if you call lock() or update() method. 3 ways of inheritance mapping: Table Per Hierarchy Table Per Concrete Class Table Per Subclass This will allow us to map their inheritance hierarchy classes with the table of the database. In table per hierarchy mapping, single table is required to map the whole hierarchy, an extra column is added to identify the class (known as discriminator column). In case of table per concrete class, tables are created as per class. But duplicate column is added in subclass tables. In table per subclass, tables are created as per class but related by foreign key. So there are no duplicate columns.","title":"Hibernate"},{"location":"javascript/","text":"","title":"JavaScript"},{"location":"nodeJS/","text":"","title":"NodeJS"},{"location":"reactJS/","text":"A Chat with Redux React: Someone clicked this 'Save' button. Action: Thanks React! I will dipatch an action so reducers that care can update state. Reducer: Ah, thanks action. I see you passed me the current state and the action to perform. I'll make a new copy of the state and return it. Store: Thanks for updating the state reducer, I'll make sure that all connected components are aware. React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this. How React Works For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent. Redux Redux enforces keeping all state in a single centralized object graph. Reducers are functions that take the current state in an action and then return a new state. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children }","title":"ReactJS"},{"location":"reactJS/#a-chat-with-redux","text":"React: Someone clicked this 'Save' button. Action: Thanks React! I will dipatch an action so reducers that care can update state. Reducer: Ah, thanks action. I see you passed me the current state and the action to perform. I'll make a new copy of the state and return it. Store: Thanks for updating the state reducer, I'll make sure that all connected components are aware. React-Redux: Woah, thanks for the new data Mr.Store. I'll now intelligently determine if I should tell React about this change so that it only has to bother with updating the UI when necessary. React: Ooh! shiny new data has been passed down via props from the store! I'll update the UI to reflect this.","title":"A Chat with Redux"},{"location":"reactJS/#how-react-works","text":"For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property. A component can only access it's own functions, props and states. Pass reference of function to another component as property, another component can use that reference with this.props.reference_name . In function component we can directly use props.property_name . Property value can be sent to component (without having any reference in component it is being used). You can pass value to reference function. Avoid function wrapper method or bind method as it creates new button for evvery render.] Use function component if it isn't top level or it's state need to be managed & no personalized event handler. Model + Component = DOM For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast. Four ways to create component: ES5 createClass ES6 class ES5 stateless function ES6 stateless function All properties of object is available as props in compnent.","title":"How React Works"},{"location":"reactJS/#redux","text":"Redux enforces keeping all state in a single centralized object graph. Reducers are functions that take the current state in an action and then return a new state. Containers are components containing the necessary logic for marshalling data and actions (via props) Redux store is immutable. The provider component attaches your application to the redux store so you use the provider component to wrap your application's top-level component. The connect wraps our component so it's connected to the redux store. children is passes down from react router { this.props.children }","title":"Redux"}]}
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Vinay Krishna" /><link rel="canonical" href="https://vinkrish.github.io/interview-reference/reactJS/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>ReactJS - Interview Reference</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "ReactJS";
        var mkdocs_page_input_path = "reactJS.md";
        var mkdocs_page_url = "/interview-reference/reactJS/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Interview Reference
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">About</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../angular/">Angular</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../java/">Java</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../javascript/">JavaScript</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">ReactJS</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../nodeJS/">NodeJS</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Interview Reference</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">ReactJS</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/vinkrish/interview-reference/edit/master/docs/reactJS.md">Edit on vinkrish/interview-reference</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h2 id="what-is-react">What is React?</h2>
<p>React is a JavaScript library developed by Facebook for building user interfaces, especially single-page applications. It is component-based, allows the development of reusable UI components, and helps in creating dynamic web apps with great performance.</p>
<h2 id="what-are-the-key-features-of-react">What are the key features of React?</h2>
<ul>
<li>Virtual DOM: Optimizes updates by re-rendering only what’s necessary.</li>
<li>Component-based architecture: Breaks UI into reusable pieces.</li>
<li>One-way data binding: Data flows in one direction (from parent to child components).</li>
<li>JSX: A syntax extension that allows writing HTML in JavaScript.</li>
<li>Declarative UI: Developers describe what UI should look like.</li>
</ul>
<h2 id="what-is-jsx">What is JSX?</h2>
<p>JSX stands for JavaScript XML. It allows writing HTML-like syntax in JavaScript code. Browsers don’t understand JSX directly, so it’s compiled into regular JavaScript using tools like Babel.</p>
<p>You can embed any JavaScript expression in JSX by wrapping it in curly braces. After compilation, JSX expressions become regular JavaScript objects. This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions</p>
<h2 id="what-are-components-in-react">What are components in React?</h2>
<p>Components are the building blocks of a React application. They allow splitting the UI into independent, reusable pieces. There are two types:</p>
<ul>
<li>Class Components: ES6 classes that extend React.Component and use lifecycle methods.</li>
<li>Functional Components: JavaScript functions that return JSX and use hooks for managing state and lifecycle.</li>
</ul>
<h2 id="what-is-the-virtual-dom-how-does-it-work">What is the Virtual DOM? How does it work?</h2>
<p>The Virtual DOM is a lightweight in-memory representation of the actual DOM. React updates the Virtual DOM first, calculates the differences (diffing), and then updates the real DOM only where necessary. This minimizes direct DOM manipulations, improving performance.</p>
<h2 id="what-are-props-in-react">What are props in React?</h2>
<p>Props (short for properties) are read-only attributes passed from a parent component to a child component. They allow passing data and methods between components.</p>
<h2 id="what-is-state-in-react">What is state in React?</h2>
<p>State is a built-in React object used to store data or information about the component. Unlike props, state is mutable and managed within the component. When state changes, React re-renders the component.</p>
<h2 id="what-is-the-difference-between-state-and-props">What is the difference between state and props?</h2>
<ul>
<li>Props are passed from parent to child components, are immutable, and allow sharing data across components.</li>
<li>State is local to the component, mutable, and used to manage internal data that can change over time.</li>
</ul>
<h2 id="what-are-hooks-in-react">What are hooks in React?</h2>
<p>Hooks are special functions that allow using state and other React features in functional components. The most commonly used hooks are:</p>
<ul>
<li>useState for state management.</li>
<li>useEffect for managing side effects like API calls, timers, etc.</li>
<li>useContext for accessing React context.</li>
<li>useMemo and useCallback for optimizing performance.</li>
</ul>
<h2 id="lifecycle-methods-in-functional-components">Lifecycle Methods in Functional Components</h2>
<p>Hooks are now the preferred way of working with React lifecycle in functional components.</p>
<pre><code class="language-js">import { useEffect } from 'react';

function MyComponent() {
  useEffect(() =&gt; {
    // componentDidMount &amp; componentDidUpdate logic
    return () =&gt; {
      // componentWillUnmount logic
    };
  }, []); // The second argument controls when the effect runs
}
</code></pre>
<h2 id="what-is-the-purpose-of-useeffect-in-react">What is the purpose of useEffect in React?</h2>
<p><code>useEffect</code> is a hook used to perform side effects in functional components, like fetching data, updating the DOM, or setting up subscriptions. It runs after the render cycle and can optionally clean up after itself by returning a function.</p>
<h2 id="how-do-you-handle-events-in-react">How do you handle events in React?</h2>
<p>Handling events in React is similar to handling events in plain JavaScript, but with a few key differences:</p>
<ul>
<li><strong>Naming Convention</strong>: React uses camelCase naming for event handlers instead of lowercase. For example, onclick in HTML becomes onClick in React.</li>
<li><strong>Passing Functions as Props</strong>: Instead of passing a string representing the event handler, you pass the actual function as a prop to the element.</li>
<li><strong>Synthetic Events</strong>: React wraps native browser events in its own synthetic event system to ensure cross-browser compatibility.</li>
</ul>
<h2 id="what-is-the-purpose-of-keys-in-react">What is the purpose of keys in React?</h2>
<p>Keys help React identify which items in a list have changed, are added, or are removed. This improves the efficiency of updating the DOM and is crucial when rendering lists of components.</p>
<h2 id="what-are-higher-order-components-hoc-in-react">What are higher-order components (HOC) in React?</h2>
<p>A HOC is a pattern in which a function takes a component and returns a new component with added functionality. It's a way to reuse component logic. For example, adding authentication checks to multiple components.</p>
<p>HOC are the best way to share behavior between React Components. If you find yourself writing a lot of code in different places that does the same thing, you may be able to refactor that code into a reusable HOC. eg: Redux’s connect function</p>
<h2 id="what-is-the-context-api-in-react">What is the Context API in React?</h2>
<p>The Context API allows for sharing state and functions across multiple components without passing props down manually at every level. It is particularly useful for managing global state like themes, user sessions, etc.</p>
<h2 id="what-is-lazy-loading-in-react">What is lazy loading in React?</h2>
<p>Lazy loading in React is a way to defer loading components until they are needed, improving the initial load time. React provides React.lazy() and Suspense for implementing lazy loading.</p>
<h2 id="what-are-react-portals">What are React portals?</h2>
<p>React portals provide a way to render components outside the main DOM hierarchy. They are useful for rendering modals, tooltips, or popups that require being placed at the root level of the DOM.</p>
<h2 id="what-is-the-difference-between-controlled-and-uncontrolled-components">What is the difference between controlled and uncontrolled components?</h2>
<ul>
<li>Controlled components are those whose form data is handled by the React component state. Input elements like <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> are controlled by the component's state using the onChange event handler.</li>
<li>Uncontrolled components use refs to directly access the DOM element’s values.</li>
</ul>
<h2 id="what-is-the-usereducer-hook">What is the useReducer hook?</h2>
<p><code>useReducer</code> is an alternative to useState when managing more complex state logic. It accepts a reducer function (state, action) and an initial state and returns the current state paired with a dispatch method to trigger state updates.</p>
<h2 id="what-is-memoization-in-react">What is memoization in React?</h2>
<p>Memoization is an optimization technique used to speed up rendering by caching results. React provides React.memo and hooks like useMemo and useCallback to avoid unnecessary re-renders and expensive computations.</p>
<h2 id="what-is-the-difference-between-usememo-and-usecallback">What is the difference between useMemo and useCallback?</h2>
<ul>
<li>useMemo: Returns a memoized value, used to optimize expensive computations.</li>
<li>useCallback: Returns a memoized function reference, useful when passing functions as props to child components to prevent re-renders.</li>
</ul>
<h2 id="how-can-you-improve-the-performance-of-a-react-app">How can you improve the performance of a React app?</h2>
<ul>
<li>Use React's memoization (React.memo, useMemo, useCallback).</li>
<li>Use Code Splitting and Lazy Loading.</li>
<li>Avoid anonymous functions in render.</li>
<li>Implement shouldComponentUpdate or use PureComponent.</li>
<li>Optimize re-rendering by managing state efficiently.</li>
<li>Use React Profiler to identify performance bottlenecks.</li>
</ul>
<h2 id="what-is-redux-and-how-does-it-relate-to-react">What is Redux, and how does it relate to React?</h2>
<p>Redux is a state management library that can be used with React (or other frameworks). It provides a central store for managing application state and follows a unidirectional data flow. In React, it's typically used with the react-redux library for binding the store with React components.</p>
<h2 id="what-is-the-difference-between-redux-and-context-api">What is the difference between Redux and Context API?</h2>
<p>Both Redux and the Context API solve similar problems: sharing state across components. However:</p>
<ul>
<li>Redux is more powerful for complex state management, providing middlewares, actions, reducers, and a strict structure.</li>
<li>Context API is simpler and suitable for smaller apps with less complex state needs.</li>
</ul>
<h2 id="what-is-react-router">What is React Router?</h2>
<p>React Router is a popular routing library for React. It allows for dynamic routing, enabling navigation between different views or components in a single-page application without refreshing the page.</p>
<h2 id="what-are-render-props">What are render props?</h2>
<p>Render props is a technique for sharing code between React components using a prop whose value is a function. It allows for more dynamic and reusable components.</p>
<h2 id="how-do-you-handle-forms-in-react">How do you handle forms in React?</h2>
<p>In React, forms can be handled using:</p>
<ul>
<li>Controlled components, where form elements are bound to the state and update via onChange handlers.</li>
<li>Uncontrolled components, using refs to access form values directly from the DOM.</li>
</ul>
<h2 id="how-react-works">How React Works</h2>
<p>Whenever a ReactComponent is changing the state, diff algorithm in React runs and identifies what has changed. And then it updates the DOM with the results of diff. The point is - it’s done faster than it would be in the regular DOM.</p>
<ul>
<li>For a component to access a state of it's parent component, the parent needs to pass the state into the child component as a property.</li>
<li>A component can only access it's own functions, props and states.</li>
<li>Pass reference of function to another component as property, another component can use that reference with <code>this.props.reference_name</code>.</li>
<li>In function component we can directly use <code>props.property_name</code>.</li>
<li>Property value can be sent to component (without having any reference in component it is being used).</li>
<li>You can pass value to reference function.</li>
<li>Avoid function wrapper method or bind method as it creates new button for evvery render.]</li>
<li>Use function component if it isn't top level or it's state need to be managed &amp; no personalized event handler.</li>
</ul>
<p><code>Model + Component = DOM</code></p>
<p>For any state change, React will regenerate the entire document object model, to avoid this problem React updates virtual DOM; which is fast.</p>
<p>Four ways to create component:</p>
<ul>
<li>ES5 createClass</li>
<li>ES6 class</li>
<li>ES5 stateless function</li>
<li>ES6 stateless function</li>
</ul>
<p>All properties of object is available as props in component, children is passes down from react router <code>{ this.props.children }</code></p>
<h2 id="redux">Redux</h2>
<p>Redux enforces keeping all state in a single centralized object graph. Redux is a predictable state container for JavaScript applications, commonly used with React to manage application state in a scalable and maintainable way. The primary concepts of Redux are:</p>
<ul>
<li>Store: A single source of truth that holds the state of the entire application.</li>
<li>Actions: Plain JavaScript objects that describe a change in the state. Every action has a type property, and optionally, a payload with data.</li>
<li>Reducers: Pure functions that take the current state and an action as arguments and return a new state. They specify how the application's state changes in response to actions.</li>
<li>Dispatch: A function that triggers actions, sending them to the reducer to modify the state.</li>
<li>Selectors: Functions that extract pieces of state from the store for use within components.</li>
</ul>
<p><strong>Redux Workflow in React</strong></p>
<p>The basic flow works as follows:</p>
<ul>
<li>Components dispatch actions: When a user interacts with a React component (e.g., button click), an action is dispatched.</li>
<li>Reducers handle actions: The action travels to the store, which then passes it to the reducer(s). Each reducer processes the action and updates the relevant part of the state.</li>
<li>Store updates: The new state is computed, and React components subscribed to the store re-render to reflect these changes.</li>
</ul>
<p>Redux Toolkit is now the recommended way to write Redux logic and is designed to address the pain points of using Redux. It simplifies the store setup and enforces best practices by providing built-in utilities.</p>
<h2 id="questions">Questions</h2>
<ol>
<li>
<p><strong>What are controlled and uncontrolled components in React?</strong></p>
<p>This relates to stateful DOM components (form elements) and the difference:</p>
<p>In HTML, form elements such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> typically maintain their own state and update it based on user input. When a user submits a form the values from the aforementioned elements are sent with the form. With React it works differently. The component containing the form will keep track of the value of the input in it's state and will re-render the component each time the callback function e.g. onChange is fired as the state will be updated. A form element whose value is controlled by React in this way is called a "controlled component".</p>
<p>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input.</p>
<p>A Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component “controls” it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a “dumb component”.</p>
<p>A Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML.
In most (or all) cases we should use controlled components.</p>
</li>
<li>
<p><strong>What is render() in React? And explain its purpose?</strong></p>
<p>Each React component must have a render() mandatorily. It returns a single React element which is the representation of the native DOM component. If more than one HTML element needs to be rendered, then they must be grouped together inside one enclosing tag such as <code>&lt;form&gt;</code>, <code>&lt;group&gt;</code>, <code>&lt;div&gt;</code> etc. This function must be kept pure i.e., it must return the same result each time it is invoked.</p>
</li>
<li>
<p><strong>What is React.cloneElement? And the difference with this.props.children?</strong></p>
<p>React.cloneElement clone and return a new React element using using the passed element as the starting point. The resulting element will have the original element's props with the new props merged in shallowly. New children will replace existing children. key and ref from the original element will be preserved.</p>
<p>React.cloneElement only works if our child is a single React element. For almost everything {this.props.children} is the better solution. Cloning is useful in some more advanced scenarios, where a parent send in an element and the child component needs to change some props on that element or add things like ref for accessing the actual DOM element.</p>
</li>
<li>
<p><strong>How Virtual-DOM is more efficient than Dirty checking?</strong></p>
<p>In React, each of our components have a state. This state is like an observable. Essentially, React knows when to re-render the scene because it is able to observe when this data changes. Dirty checking is slower than observables because we must poll the data at a regular interval and check all of the values in the data structure recursively. By comparison, setting a value on the state will signal to a listener that some state has changed, so React can simply listen for change events on the state and queue up re-rendering.</p>
<p>The virtual DOM is used for efficient re-rendering of the DOM. This isn’t really related to dirty checking your data. We could re-render using a virtual DOM with or without dirty checking. In fact, the diff algorithm is a dirty checker itself.</p>
<p>We aim to re-render the virtual tree only when the state changes. So using an observable to check if the state has changed is an efficient way to prevent unnecessary re-renders, which would cause lots of unnecessary tree diffs. If nothing has changed, we do nothing.</p>
</li>
<li>
<p><strong>What is PureComponent? When to use PureComponent over Component?</strong></p>
<p>PureComponent is exactly the same as Component except that it handles the shouldComponentUpdate method for us. When props or state changes, PureComponent will do a shallow comparison on both props and state. Component on the other hand won't compare current props and state to next out of the box. Thus, the component will re-render by default whenever shouldComponentUpdate is called.</p>
<p>When comparing previous props and state to next, a shallow comparison will check that primitives have the same value (eg, 1 equals 1 or that true equals true) and that the references are the same between more complex javascript values like objects and arrays.</p>
<p>It is good to prefer PureComponent over Component whenever we never mutate our objects.</p>
</li>
</ol>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../javascript/" class="btn btn-neutral float-left" title="JavaScript"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../nodeJS/" class="btn btn-neutral float-right" title="NodeJS">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/vinkrish/interview-reference" class="fa fa-code-fork" style="color: #fcfcfc"> vinkrish/interview-reference</a>
        </span>
    
    
      <span><a href="../javascript/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../nodeJS/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
